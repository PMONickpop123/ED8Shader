
uniform sampler2D LowResDepthTexture;
uniform sampler2D DitherNoiseTexture;

#define FPS_MAX	30

struct DirectionalLight
{
	half3 m_direction;
	half3 m_colorIntensity;
};

// 影受けバイアス値
#define SHADOW_LIGHTDIR_BIAS	0.05
#define SHADOW_NORMALDIR_BIAS	0.05

struct CombinedCascadedShadowMap
{
	// 二分割
	float4x4 m_split0Transform;
	float4x4 m_split1Transform;

	float4 m_splitDistances;
};

#define NUM_SKIN_TRANSFORMS	160
layout(std140) uniform Param
{
uniform SceneWideParameters scene;

uniform float4x4 World;
uniform float GlobalTexcoordFactor;
uniform float FogRatio;
uniform float2 WindyGrassDirection;
uniform float WindyGrassSpeed;
uniform float WindyGrassHomogenity;
uniform float WindyGrassScale;

uniform DirectionalLight Light0;
uniform CombinedCascadedShadowMap LightShadow0;
uniform float EncodedMainLightClampFactor;
uniform float4 GameMaterialDiffuse;
uniform float4 GameMaterialEmission;
uniform float GameMaterialMonotone;
uniform float4 GameMaterialTexcoord;
uniform float4 GameDitherParams;
uniform float4 UVaMUvColor;
uniform float4 UVaProjTexcoord;
uniform float4 UVaMUvTexcoord;
uniform float4 UVaMUv2Texcoord;
uniform float4 UVaDuDvTexcoord;
uniform float AlphaThreshold;
uniform float3 ShadowColorShift;
uniform float Shininess;
uniform float SpecularPower;
uniform float3 SpecularColor;
uniform float3 RimLitColor;
uniform float RimLitIntensity;
uniform float RimLitPower;
uniform float RimLightClampFactor;
uniform float BlendMulScale2;
uniform float BlendMulScale3;
uniform float SphereMapIntensity;
uniform float CubeMapIntensity;
uniform float CubeMapFresnel;
uniform float2 ProjectionScale;
uniform float2 DuDvMapImageSize;
uniform float2 DuDvScale;
uniform float BloomIntensity;
uniform float GlareIntensity;
uniform float ReflectionIntensity;
uniform float ReflectionFresnel;
uniform float MaskEps;
uniform float4 PointLightParams;
uniform float4 PointLightColor;

uniform float4x4 BoneTransforms[NUM_SKIN_TRANSFORMS];
};

//=============================================================================
// マテリアルスイッチのプリプロセス
//=============================================================================

// ブルームは常時ON
#define BLOOM_ENABLED

// 水面反射モデルに対する軽量化
#if defined(USER_CLIP_PLANE)
	#if !defined(INSTANCING_ENABLED)	//ノーマル切ると正しく表示されないインスタンスがある
	#undef NORMAL_MAPPING_ENABLED
	#undef MULTI_UV_NORMAL_MAPPING_ENABLED
	#endif
	#undef CASTS_SHADOWS
	#undef RECEIVE_SHADOWS
#endif // defined(USER_CLIP_PLANE)

// 非マルチテクスチャなら関連スイッチを無効化
#if !defined(MULTI_UV_ENANLED)
	#undef MULTI_UV_ADDITIVE_BLENDING_ENANLED
	#undef MULTI_UV_MULTIPLICATIVE_BLENDING_ENANLED
	#undef MULTI_UV_MULTIPLICATIVE_BLENDING_LM_ENANLED
	#undef MULTI_UV_MULTIPLICATIVE_BLENDING_EX_ENANLED
	#undef MULTI_UV_NORMAL_MAPPING_ENABLED
	#undef MULTI_UV_SPECULAR_MAPPING_ENABLED
	#undef MULTI_UV_GLARE_MAP_ENABLED
	#undef MULTI_UV2_ENANLED
	#undef MULTI_UV2_ADDITIVE_BLENDING_ENANLED
	#undef MULTI_UV2_MULTIPLICATIVE_BLENDING_ENANLED
	#undef MULTI_UV2_MULTIPLICATIVE_BLENDING_LM_ENANLED
	#undef MULTI_UV2_MULTIPLICATIVE_BLENDING_EX_ENANLED
#endif // !defined(MULTI_UV_ENANLED)

// マルチUV2と排他なものを無効化
#if defined(MULTI_UV2_ENANLED)
	#undef SPHERE_MAPPING_ENABLED
	#undef CUBE_MAPPING_ENABLED
#endif

#if defined(WATER_SURFACE_ENABLED)
	#undef ALPHA_BLENDING_ENABLED
	#undef ADDITIVE_BLENDING_ENABLED
	#undef SUBTRACT_BLENDING_ENABLED
	#undef MULTIPLICATIVE_BLENDING_ENABLED
#endif // defined(WATER_SURFACE_ENABLED)

#if !defined(ALPHA_BLENDING_ENABLED)
	#undef ADDITIVE_BLENDING_ENABLED
	#undef SUBTRACT_BLENDING_ENABLED
	#undef MULTIPLICATIVE_BLENDING_ENABLED
#endif

#if defined(NUM_LIGHTS)
	#if (NUM_LIGHTS > 0) && !defined(NOTHING_ENABLED) && !defined(NO_ALL_LIGHTING_ENABLED)
		#define USE_LIGHTING
	#endif
#endif

#if defined(RECEIVE_SHADOWS)
	#if defined(NUM_LIGHTS)
		#if NUM_LIGHTS == 0
			#undef RECEIVE_SHADOWS
		#endif
	#else
		#undef RECEIVE_SHADOWS
	#endif
	#if !defined(SHADOWTYPE_0)
		#undef RECEIVE_SHADOWS
	#endif
#endif // defined(RECEIVE_SHADOWS)

#if defined(NORMAL_MAPPING_ENABLED) || defined(MULTI_UV_NORMAL_MAPPING_ENABLED)
	#define USE_TANGENTS
#endif

#if defined(ADDITIVE_BLENDING_ENABLED) || defined(SUBTRACT_BLENDING_ENABLED) || defined(MULTIPLICATIVE_BLENDING_ENABLED)
	#define USE_EXTRA_BLENDING
#endif

//=============================================================================
// グローバルシェーダパラメータ
//=============================================================================

//-----------------------------------------------------------------------------
// ライティング
//-----------------------------------------------------------------------------

#if defined(RECEIVE_SHADOWS)
uniform sampler2DShadow LightShadowMap0;
#endif // defined(RECEIVE_SHADOWS)

#define MainLightClampFactor	1.5

//-----------------------------------------------------------------------------
// テクスチャ
//-----------------------------------------------------------------------------
uniform sampler2D DiffuseMapSampler;

#if defined(NORMAL_MAPPING_ENABLED)
uniform sampler2D NormalMapSampler;
#endif

#if defined(SPECULAR_MAPPING_ENABLED)
uniform sampler2D SpecularMapSampler;
#endif

#if defined(EMISSION_MAPPING_ENABLED)
uniform sampler2D EmissionMapSampler;
#endif

//-----------------------------------------------------------------------------
// マルチUVテクスチャ
//-----------------------------------------------------------------------------
#if defined(MULTI_UV_ENANLED)
uniform sampler2D DiffuseMap2Sampler;

	#if defined(MULTI_UV_SPECULAR_MAPPING_ENABLED)
uniform sampler2D SpecularMap2Sampler;
	#endif

	#if defined(MULTI_UV_NORMAL_MAPPING_ENABLED)
uniform sampler2D NormalMap2Sampler;
	#endif
#endif // defined(MULTI_UV_ENANLED)

//-----------------------------------------------------------------------------
// マルチUV2テクスチャ
//-----------------------------------------------------------------------------
#if defined(MULTI_UV2_ENANLED)
uniform sampler2D DiffuseMap3Sampler;
#endif // defined(MULTI_UV2_ENANLED)

//-----------------------------------------------------------------------------
// スフィアマップ
//-----------------------------------------------------------------------------
#if defined(SPHERE_MAPPING_ENABLED)
uniform sampler2D SphereMapSampler;
#endif // defined(SPHERE_MAPPING_ENABLED)

//-----------------------------------------------------------------------------
// キューブマップ
//-----------------------------------------------------------------------------
#if defined(CUBE_MAPPING_ENABLED)
uniform samplerCUBE CubeMapSampler;
#endif // defined(CUBE_MAPPING_ENABLED)

//-----------------------------------------------------------------------------
// 射影マップ
//-----------------------------------------------------------------------------
#if defined(PROJECTION_MAP_ENABLED)
uniform sampler2D ProjectionMapSampler;
#endif // defined(PROJECTION_MAP_ENABLED)

//-----------------------------------------------------------------------------
// DU/DVマップ
//-----------------------------------------------------------------------------
#if defined(DUDV_MAPPING_ENABLED)
uniform sampler2D DuDvMapSampler;

	#define DUDVMAP_SIZE	256.0
#endif // defined(DUDV_MAPPING_ENABLED)

//-----------------------------------------------------------------------------
// グロー
//-----------------------------------------------------------------------------
#if defined(GLARE_ENABLED)
	#if defined(GLARE_MAP_ENABLED)
uniform sampler2D GlareMapSampler;
	#endif
	#if defined(MULTI_UV_GLARE_MAP_ENABLED)
uniform sampler2D GlareMap2Sampler;
	#endif
#endif // defined(GLARE_ENABLED)

//-----------------------------------------------------------------------------
// 映り込み
//-----------------------------------------------------------------------------
uniform sampler2D ReflectionTexture;
uniform sampler2D RefractionTexture;

//=============================================================================
// シェーダ入出力構造体
//=============================================================================
struct DefaultVPOutput
{
	float4 Position;
	half4 Color0;
	half4 Color1;		// xyz = 未使用, w = フォグ計算結果
	float2 TexCoord;
	float4 WorldPositionDepth;	// xyz = ワールド座標, w = 視線方向のZ値

	float2 TexCoord2;

	float2 ProjMap;

	float3 Normal;

	float2 DuDvTexCoord;

	float3 Tangent;

	float2 TexCoord3;

	float4 instanceParam;

	float4 wvpPos;
};

#if defined(USE_MRT)
struct DefaultFPOutputMRT
{
	float4 Color;	// rgb = 色, a = 輝度（ブルーム用）
	float4 Normal;	// rgb = 法線（0.0～1.0に正規化）, a = ライティング上限
	float4 Depth;	// rgb = 深度（精度維持のためエンコード）, a = マスク
};
#endif // defined(USE_MRT)

//-----------------------------------------------------------------------------
// 深度値用
//-----------------------------------------------------------------------------
struct TransparentDepthVPOutput
{
	float4 Position;
	half4 Color0;
	float2 TexCoord;	// xy = テクスチャ座標, z = Fog
};

//=============================================================================
// サブルーチン
//=============================================================================

//-----------------------------------------------------------------------------
// 深度
//-----------------------------------------------------------------------------
float3 encodeDepth(float depth)
{
	float4 unpacked_depth = float4(0, 0, 256.0f, 256.0f);
	unpacked_depth.g = modf(depth * 256.0f, unpacked_depth.r);
	unpacked_depth.b *= modf(unpacked_depth.g * 256.0f, unpacked_depth.g);
	unpacked_depth /= 256.0f;	// 最後にまとめて割り算する方が速い
	return unpacked_depth.rgb;	// float型の仮数部が23bitの精度しかないため、24bit目まで計算すれば十分
}

float decodeDepth(float3 color)
{
	float depth = color.r + (color.g + color.b / 256.0f) / 256.0f;
	return depth;
}

//-----------------------------------------------------------------------------
// マスク
//-----------------------------------------------------------------------------
#define GBUF_MASK_NONE		0x00
#define GBUF_MASK_CHR		0x01
#define GBUF_MASK_NO_SSAO	0x02
#define GBUF_MASK_OUTLINE	0x04
#define GBUF_MASK_NO_LIGHT	0x08

float encodeMask(uint mask)
{
//	return float(mask) * (1.0/255.0) + 0.00001;
	return float(mask) * (1.0/255.0) + MaskEps;
}

uint decodeMask(float mask)
{
	return uint(mask * 255.00001);
}

//-----------------------------------------------------------------------------
// 法線
//-----------------------------------------------------------------------------
float3 encodeNormal(float3 normal)
{
	return normal * 0.5 + 0.5;
}

float3 decodeNormal(float3 normal)
{
	return normal * 2.0 - 1.0;
}

//-----------------------------------------------------------------------------
// 速度
//-----------------------------------------------------------------------------
#define GBUF_VEL_ZERO	(7<<4 | 7)

float encodeVelocity(float2 velocity)
{
	velocity = velocity * 0.5 + 0.5;
	float2 n = float2(velocity * 15);
	uint bit = (uint(n.x) << 4) | uint(n.y);
	return encodeMask(bit);
}

float2 _decodeVelocity(uint bit)
{
	float2 n = float2((int(bit) >> 4) & 0xF, int(bit) & 0xF);
	float2 v = float2(n) * (1.0/15.0);
	v = min(float2(2.0,2.0), v / (7.0/15.0)) / 2;	//正の方向だけ少し長いことに対する補正
	return v * 2.0 - 1.0;
}

float2 decodeVelocity(float velocity)
{
	return _decodeVelocity(decodeMask(velocity));
}

half ClampPlusMinusOneToNonNegative(half value)
{
	return saturate(value);
}

float4 GenerateScreenProjectedUv(float4 projPosition)
{
	float2 clipSpaceDivided = projPosition.xy / float2(projPosition.w, -projPosition.w);
	float2 tc = clipSpaceDivided.xy * 0.5 + 0.5;
	return float4(tc.x * projPosition.w, tc.y * projPosition.w, 0, projPosition.w);
}

float3 GetEyePosition()
{
	return float3(scene.EyePosition);
}

half3 GetGlobalAmbientColor()
{
	return scene.GlobalAmbientColor.rgb;
}

float2 GetGlobalTextureFactor()
{
	return float2(GlobalTexcoordFactor);
}

float3 GetFakeSpecularLightDir(float3 trueLightDir)
{
	return scene.FakeRimLightDir;
}

//-----------------------------------------------------------------------------
// インスタンシング
//-----------------------------------------------------------------------------
#if defined(INSTANCING_ENABLED)
float GetDitherThreshold(float2 screenPos)
{
	float2 matrixUv = screenPos * (1.0/4);
	return _tex2Dlod(PointWrapSamplerState, DitherNoiseTexture, matrixUv, 0).x;
}
#endif // defined(INSTANCING_ENABLED)

//-----------------------------------------------------------------------------
// 輝度計算
//-----------------------------------------------------------------------------

// 輝度レンジ。上げ過ぎるとマッハバンド酷くなるので注意！
#define BRIGHT_RANGE		(2.0)
#define BRIGHT_RANGE_RCP	(1 / BRIGHT_RANGE)

#if defined(GLARE_ENABLED)
half CalcGlowValue(half val)
{
	const half glowIntensity = BRIGHT_RANGE;
	return min(1, val * glowIntensity * BRIGHT_RANGE_RCP);
}
#endif // defined(GLARE_ENABLED)

#if defined(BLOOM_ENABLED)
half CalcBrightness(half3 rgb)
{
	half bright = dot(rgb * BloomIntensity, half3(0.299, 0.587, 0.114));
	half threshold = scene.MiscParameters2.z;
	bright = max(0, bright - threshold);
	return min(1, bright * BRIGHT_RANGE_RCP);
}
#endif // defined(BLOOM_ENABLED)

//-----------------------------------------------------------------------------
// ライティング
//-----------------------------------------------------------------------------
half calcDiffuseLightAmtLdotN(half ldotn)
{
	half diffuseValue;
#if 1	// ハーフランバートで固定
	diffuseValue = ldotn * 0.5 + 0.5;
	diffuseValue *= diffuseValue;
#else
	diffuseValue = ClampPlusMinusOneToNonNegative(ldotn);
#endif
	return diffuseValue;
}

half calcSpecularLightAmt(half3 normal, half3 lightDir, half3 eyeDirection, half shininess, half specularPower)
{
	half3 halfVec = normalize(eyeDirection + lightDir);
	half nDotH = ClampPlusMinusOneToNonNegative(dot(normal,halfVec));
	half specularLightAmount = ClampPlusMinusOneToNonNegative(pow(nDotH, specularPower)) * shininess;
	return specularLightAmount;
}

half calcEmissionBias(half ndote)
{
#if defined(DOUBLE_SIDED)
	half bias = pow(max(0, 1.0 - abs(ndote)), PointLightColor.x);
#else
	half bias = pow(1.0 - clamp(ndote, 0.0, 1.0), PointLightColor.x);
#endif
	return lerp(1.0, bias, PointLightColor.y);
}

//-----------------------------------------------------------------------------
// 法線マップ
//-----------------------------------------------------------------------------
half3 EvaluateNormalMapNormal(half3 inNormal, float2 inUv, half3 inTangent, sampler2D normalMapSampler)
{
	half4 normalMapData = _h4tex2D(normalMapSamplerSampler, normalMapSampler, inUv).xyzw;

#if defined(NORMAL_MAPP_DXT5_NM_ENABLED)

	half3 normalMapNormal;
	normalMapNormal.x = normalMapData.a * 2.0 - 1.0;
	normalMapNormal.y = normalMapData.r * 2.0 - 1.0;
	normalMapNormal.z = sqrt(1 - saturate(normalMapNormal.x * normalMapNormal.x - normalMapNormal.y * normalMapNormal.y));

#elif defined(NORMAL_MAPP_DXT5_LP_ENABLED)

	normalMapData = normalMapData * 2.0 - 1.0;
	half3 normalMapNormal;
	normalMapNormal.x = normalMapData.r * normalMapData.a;
	normalMapNormal.y = normalMapData.g;
	normalMapNormal.z = sqrt(1 - saturate(normalMapNormal.x * normalMapNormal.x - normalMapNormal.y * normalMapNormal.y));

#else // defined(NORMAL_MAPP_DXT5_NM_ENABLED)

	half3 normalMapNormal = normalMapData.xyz * 2.0 - 1.0;

#endif // defined(NORMAL_MAPP_DXT5_NM_ENABLED)

	inTangent = normalize(inTangent);
	inNormal = normalize(inNormal);

	// tangenが逆のケースを考慮
//	inTangent = normalize(inTangent - dot(inTangent, inNormal) * inNormal);

	half3 biTangent = cross(inNormal, inTangent);

	// xはUフリップとして負の値にしていることがある
	normalMapNormal.x *= (inUv.x < 0.0) ? -1.0 : 1.0;

	half3 n =  normalize((normalMapNormal.x * inTangent) +
						 (normalMapNormal.y * biTangent) +
						 (normalMapNormal.z * inNormal));
	return n;
}

half3 EvaluateStandardNormal(half3 inNormal)
{
	return normalize(inNormal).xyz;
}

	#define _EvaluateNormalMapNormal(a,b,c,d) EvaluateNormalMapNormal(a, b, c, d)

#if defined(NORMAL_MAPPING_ENABLED)
	#if defined(DUDV_MAPPING_ENABLED)
		#define EvaluateNormalFP(In) _EvaluateNormalMapNormal(In.Normal.xyz, In.TexCoord.xy + dudvValue, In.Tangent, NormalMapSampler)
	#else
		#define EvaluateNormalFP(In) _EvaluateNormalMapNormal(In.Normal.xyz, In.TexCoord.xy, In.Tangent, NormalMapSampler)
	#endif
#else
	#define EvaluateNormalFP(In) EvaluateStandardNormal(In.Normal.xyz)
#endif

#if defined(MULTI_UV_NORMAL_MAPPING_ENABLED)
	#if defined(DUDV_MAPPING_ENABLED)
		#define EvaluateNormal2FP(In) _EvaluateNormalMapNormal(In.Normal.xyz, In.TexCoord2.xy + dudvValue, In.Tangent, NormalMap2Sampler)
	#else
		#define EvaluateNormal2FP(In) _EvaluateNormalMapNormal(In.Normal.xyz, In.TexCoord2.xy, In.Tangent, NormalMap2Sampler)
	#endif
#else
	#define EvaluateNormal2FP(In) EvaluateStandardNormal(In.Normal.xyz)
#endif

//-----------------------------------------------------------------------------
// フォグ
//-----------------------------------------------------------------------------
float EvaluateFogColor(inout half3 resultColor, half fogValue, float3 worldPos)
{
	#if defined(USE_EXTRA_BLENDING)
		#if defined(MULTIPLICATIVE_BLENDING_ENABLED)
	half3 fogColor = half3(1.0);
		#else
	half3 fogColor = half3(0.0);
		#endif
	#else
	half3 fogColor = scene.FogColor.rgb;
	#endif
	if (scene.MiscParameters6.w > 0) {
		worldPos.xz += scene.MiscParameters6.xy * FPS_MAX * GetGlobalTextureFactor();
		worldPos *= scene.MiscParameters6.z;
		float3 d = float3(
			_tex2Dlod(LinearWrapSamplerState, LowResDepthTexture, worldPos.xy, 0).x,
			_tex2Dlod(LinearWrapSamplerState, LowResDepthTexture, worldPos.xz, 0).x,
			_tex2Dlod(LinearWrapSamplerState, LowResDepthTexture, worldPos.yz, 0).x);
		float density = dot(d, float3(0.3333, 0.3333, 0.3333));
		fogValue = max(0.0, fogValue - (density * fogValue * scene.MiscParameters6.w));
	}
	resultColor.rgb = lerp(resultColor.rgb, fogColor.rgb, fogValue);
	return fogValue;
}

#if defined(RECEIVE_SHADOWS)
//-----------------------------------------------------------------------------
// シャドウマップ
//-----------------------------------------------------------------------------
half SampleOrthographicShadowMap(float4 shadowPosition, sampler2DShadow shadowMapSampler)
{
	return h4tex2D(shadowMapSampler, shadowPosition.xyz).x;
}

// 1 1
//  4
// 1 1
half SampleOrthographicShadowMapPCF5(float4 shadowPosition, sampler2DShadow shadowMapSampler, float sampleOffsetScale)
{
	float w = shadowPosition.w * scene.MiscParameters4.x * sampleOffsetScale;
	float h = shadowPosition.w * scene.MiscParameters4.y * sampleOffsetScale;
	float4 sampleOffsets[5] = float4[]
	(
		float4( 0, 0, 0, 0),
		float4(-w,-h, 0, 0),
		float4( w,-h, 0, 0),
		float4(-w, h, 0, 0),
		float4( w, h, 0, 0)
	);
	float shadowWeights[5] = float[]
	(
//		0.500f,
//		0.125f,
//		0.125f,
//		0.125f,
//		0.125f
		scene.MiscParameters5.x,
		scene.MiscParameters5.y,
		scene.MiscParameters5.y,
		scene.MiscParameters5.y,
		scene.MiscParameters5.y
	);
	float shadowRslt = 0;
	for(int i = 0; i < 5; ++i)
	{
		shadowRslt += SampleOrthographicShadowMap(shadowPosition + sampleOffsets[i], shadowMapSampler) * shadowWeights[i];
	}
	return shadowRslt;
}

#define _SampleOrthographicShadowMap(a, b, c) SampleOrthographicShadowMapPCF5(a, b, c)

half EvaluateShadow(CombinedCascadedShadowMap shadow, sampler2DShadow shadowMapSampler, float3 worldPosition, float viewDepth)
{
	half result = 1;

	//
	// 二分割
	//

	if (viewDepth > shadow.m_splitDistances.y)
	{
		return 1.0;
	}

	if (viewDepth < shadow.m_splitDistances.x)
	{
		// 近
		float4 shadowPosition = _mul(shadow.m_split0Transform, float4(worldPosition, 1));
		result = _SampleOrthographicShadowMap(shadowPosition, shadowMapSampler, 1.0);
	}
	else
	{
		// 遠
		float4 shadowPosition = _mul(shadow.m_split1Transform, float4(worldPosition, 1));
		result = _SampleOrthographicShadowMap(shadowPosition, shadowMapSampler, scene.MiscParameters4.z);
	}

	return result;
}

half EvaluateShadow(float dummy, float dummy2, float3 worldPosition, float viewDepth)
{
	return 1;
}

// 影濃度のバイアス値を求める（深度）
half EvaluateShadowDensityBias_Depth(CombinedCascadedShadowMap shadow, float viewDepth)
{
	half bias = 1.0;

	//
	// 二分割
	//

	bias = saturate(viewDepth / shadow.m_splitDistances.y);

	bias = pow(bias, 3);
	return bias;
}

// 影濃度のバイアス値を求める（高さ）
half EvaluateShadowDensityBias_Height(float y)
{
	if (scene.MiscParameters2.x > 0)
	{
		half bias = min(abs(y - scene.MiscParameters2.y) * scene.MiscParameters2.x, 1);
		bias = pow(bias, 3);
		return bias;
	}
	return 0.0;
}

// 影濃度のバイアス値を求める（傾斜、マップ用）
half EvaluateShadowDensityBias_Angle_Map(float3 normal, float3 lightDir)
{
	half bias = dot(normal, lightDir);
	bias = bias * 0.5 + 0.5;
	half threshold = 0.4;
	threshold -= threshold * half(scene.MiscParameters4.w) * half(max(dot(normal, float3(0, -1, 0)), 0));	// 側面や底部の影濃度を底上げ
	if (bias > threshold)
	{
		bias = (bias - threshold) / (1 - threshold);
	}
	else
	{
		bias = 0;
	}
	bias = 1 - bias;
	bias = pow(bias, 3);
	return bias;
}

#endif // defined(RECEIVE_SHADOWS)

//-----------------------------------------------------------------------------
// ライティング
//-----------------------------------------------------------------------------
void EvaluateDiffuseAndSpecular(out half3 diffuseValue, out half ldotn, float3 normal, float3 lightDir, half3 lightColor
#if defined(SPECULAR_ENABLED)
, out half3 specularValue, float3 specularLightDir, float3 eyeDirection, half shininess, half specularPower
#endif
)
{
#if defined(NO_MAIN_LIGHT_SHADING_ENABLED)
	ldotn = dot(lightDir, normal);
	diffuseValue = lightColor / max(max(lightColor.r, lightColor.g), max(lightColor.b, 0.001));	// 一番大きい色成分で正規化
#else
	ldotn = dot(lightDir, normal);
	diffuseValue = lightColor * calcDiffuseLightAmtLdotN(ldotn);
#endif

#if defined(SPECULAR_ENABLED)
	specularValue = lightColor
	#if defined(SPECULAR_COLOR_ENABLED)
	* SpecularColor
	#endif
	* calcSpecularLightAmt(normal, specularLightDir, eyeDirection, shininess, specularPower);
#endif
}

void EvaluateLight(DirectionalLight light, out half ldotn, out half3 diffuseValue, out float3 lightDir, float3 worldSpacePosition, float3 normal
#if defined(SPECULAR_ENABLED)
, out half3 specularValue, float3 eyeDirection, half shininess, half specularPower
#endif
)
{
	float3 lightDirTmp = light.m_direction;
	lightDir = lightDirTmp;

#if defined(FAKE_CONSTANT_SPECULAR_ENABLED)
	float3 specularLightDir = GetFakeSpecularLightDir(lightDirTmp);
#else
	float3 specularLightDir = lightDirTmp;
#endif
	EvaluateDiffuseAndSpecular(diffuseValue, ldotn, normal, lightDirTmp, light.m_colorIntensity
#if defined(SPECULAR_ENABLED)
	, specularValue, specularLightDir, eyeDirection, shininess, specularPower
#endif
	);
}

#if defined(USE_LIGHTING)

// ピクセル単位ライティング
half3 EvaluateLightingPerPixel(float3 worldSpacePosition, float3 normal, half glossValue, half shadowValue, half3 ambientAmount, float3 eyeDirection)
{
	half3 lightingResult;

	#if defined(ALPHA_BLENDING_ENABLED) && defined(USE_EXTRA_BLENDING)
	lightingResult = half3(0);
	#else
	lightingResult = ambientAmount;
	#endif
	half3 shadingAmount = half3(0.0,0.0,0.0);
	half3 lightingAmount = half3(0.0,0.0,0.0);
	#if defined(SPECULAR_ENABLED)
	half shininess = Shininess * glossValue;
	#endif

	float3 lightDir_ = float3(0);
	half3 diffuseValue_ = half3(0.0,0.0,0.0);
	half3 specularValue_ = half3(0.0,0.0,0.0);
	half ldotn_ = 0;
	EvaluateLight(Light0, ldotn_, diffuseValue_, lightDir_, worldSpacePosition, normal
	#if defined(SPECULAR_ENABLED)
	, specularValue_, eyeDirection, shininess, SpecularPower
	#endif
	);

	diffuseValue_ *= shadowValue;

	#if defined(SPECULAR_ENABLED)
	lightingAmount += specularValue_;
	lightingAmount *= shadowValue;
	#endif

	shadingAmount += diffuseValue_;

	lightingResult += shadingAmount;
	lightingResult = min(lightingResult, half3(MainLightClampFactor));

	#if defined(SPECULAR_ENABLED)
	lightingResult += lightingAmount;
	#endif

	return lightingResult;
}

#else // !defined(USE_PER_VERTEX_LIGHTING) && defined(USE_LIGHTING)

// 頂点単位ライティング(FP)
half3 EvaluateLightingPerVertexFP(half glossValue, half shadowValue, half3 ambientAmount, half3 shadingAmount, half3 lightingAmount)
{
	half3 lightingResult;
	#if defined(MULTIPLICATIVE_BLENDING_ENABLED)
	shadowValue = 1.0;
	#endif
	lightingResult = max(GetGlobalAmbientColor(), half3(shadowValue));
	lightingResult = min(lightingResult, half3(MainLightClampFactor));
	return lightingResult;
}

#endif // !defined(USE_PER_VERTEX_LIGHTING) && defined(USE_LIGHTING)

//-----------------------------------------------------------------------------
// リムライト
//-----------------------------------------------------------------------------
#if defined(RIM_LIGHTING_ENABLED)
half EvaluateRimLightValue(half ndote)
{
	#if defined(DOUBLE_SIDED)
	half rimLightvalue = pow(max(0, 1.0 - abs(ndote)), RimLitPower);
	#else
	half rimLightvalue = pow(1.0 - clamp(ndote, 0.0, 1.0), RimLitPower);	// リムが内側によってしまうのを防ぐ
	#endif
	return rimLightvalue * RimLitIntensity;
}

half3 ClampRimLighting(half3 ambient)
{
	return min(ambient, half3(RimLightClampFactor));
}
#endif // defined(RIM_LIGHTING_ENABLED)

//=============================================================================
// 頂点・フラグメントシェーダ
//=============================================================================

#if defined(main_DefaultFPShader) || defined(main_ForceTransparentFPShader)

#if defined(main_DefaultFPShader)
#define FP_DEFAULT
	#if defined(USE_MRT)
DefaultFPOutputMRT DefaultFPShader(DefaultVPOutput IN, float4 ScreenPosition)
	#else
half4 DefaultFPShader(DefaultVPOutput IN, float4 ScreenPosition)
	#endif
#elif defined(main_ForceTransparentFPShader)
#define FP_FORCETRANSPARENT
half4 ForceTransparentFPShader(DefaultVPOutput IN, float4 ScreenPosition)
#endif // defined(FP_DEFAULT)
{
#if defined(NOTHING_ENABLED)

	half4 resultColor = IN.Color0;
	
	// シェーダ外部からのカラー操作
	resultColor *= (half4)GameMaterialDiffuse;
	resultColor.rgb += (half3)GameMaterialEmission.rgb;

	#if defined(FP_DEFAULT)
	half4 resultColor2 = half4(0,0,0,0);
		#if !defined(ALPHA_BLENDING_ENABLED)
	resultColor2 = half4(resultColor.rgb, 0);
		#else
	resultColor2 = resultColor;
		#endif
		#if defined(USE_MRT)
	// MRTが有効なら色以外の情報も出力
	DefaultFPOutputMRT resultMRT;
	resultMRT.Color = resultColor2;
	resultMRT.Normal = float4(0,0,0,0);	// 不要
	resultMRT.Depth = float4(0,0,0,0);	// 不要
	return resultMRT;
		#else // defined(USE_MRT)
	return resultColor2;
		#endif // defined(USE_MRT)
	#elif defined(FP_FORCETRANSPARENT)
	return resultColor;
	#endif

#else // defined(NOTHING_ENABLED)

#if defined(INSTANCING_ENABLED)
	float ditherThreshold = GetDitherThreshold(ScreenPosition.xy);
	#if defined(FAR_CLIP_BY_DITHER_ENABLED)
	// ディザリングによる距離クリップ
	clip(IN.instanceParam.x - ditherThreshold);
	#else
	// ディザリングによるモデル切替
	float ditherResult = IN.instanceParam.y - ditherThreshold;
	ditherResult = (sign(IN.instanceParam.z) < 0) ? -ditherResult : ditherResult;
	clip(ditherResult);
	#endif
#endif

#if defined(USER_CLIP_PLANE)
	// 任意平面でクリップ
	float3 waterNorm = float3(IN.WorldPositionDepth.x, IN.WorldPositionDepth.y, IN.WorldPositionDepth.z) - scene.UserClipPlane2.xyz;
	clip(dot(scene.UserClipPlane.xyz, normalize(waterNorm)));
#endif

#if defined(DUDV_MAPPING_ENABLED)
	half2 dudvValue_ = _h4tex2D(DuDvMapSamplerSampler, DuDvMapSampler, IN.DuDvTexCoord.xy).xy * 2.0 - 1.0;
	half2 dudvValue = dudvValue_ * (DuDvScale / DuDvMapImageSize);
	half4 diffuseAmt = _h4tex2D(DiffuseMapSamplerSampler, DiffuseMapSampler, IN.TexCoord.xy + dudvValue);
#else
	half4 diffuseAmt = _h4tex2D(DiffuseMapSamplerSampler, DiffuseMapSampler, IN.TexCoord.xy);
#endif
	diffuseAmt.a *= half(IN.Color0.a);

	// アルファテスト
#if defined(ALPHA_BLENDING_ENABLED) || defined(ALPHA_TESTING_ENABLED)
	#if defined(ALPHA_TESTING_ENABLED)
	clip(diffuseAmt.a - AlphaThreshold * half(IN.Color0.a));
	#else
	clip(diffuseAmt.a - 0.004);
	#endif
#endif // defined(ALPHA_BLENDING_ENABLED) || defined(ALPHA_TESTING_ENABLED)

	// DUDV
	#if defined(WATER_SURFACE_ENABLED) || defined(DUDV_MAPPING_ENABLED) || defined(FP_FORCETRANSPARENT)
	float4 screenUv = float4(ScreenPosition.x / scene.ViewportWidthHeight.x, ScreenPosition.y / scene.ViewportWidthHeight.y, 0, 1);
	float2 screenUvBase = screenUv.xy;
		#if defined(DUDV_MAPPING_ENABLED)
	float2 dudvAmt = dudvValue * half2(DuDvMapImageSize.x / scene.ViewportWidthHeight.x, DuDvMapImageSize.y / scene.ViewportWidthHeight.y);
	screenUv.xy += dudvAmt;
			#define FP_DUDV_AMT_EXIST
		#endif
	#endif // defined(WATER_SURFACE_ENABLED) || defined(DUDV_MAPPING_ENABLED) || defined(FP_FORCETRANSPARENT)

	// マルチUV
#if defined(MULTI_UV_ENANLED)
	#if defined(DUDV_MAPPING_ENABLED)
	half4 diffuse2Amt = _h4tex2D(DiffuseMap2SamplerSampler, DiffuseMap2Sampler, IN.TexCoord2.xy + dudvValue);
	#else
	half4 diffuse2Amt = _h4tex2D(DiffuseMap2SamplerSampler, DiffuseMap2Sampler, IN.TexCoord2.xy);
	#endif
	diffuse2Amt *= half4(UVaMUvColor);

	half multi_uv_alpha = half(IN.Color0.a) * diffuse2Amt.a;
	#if defined(MULTI_UV_ADDITIVE_BLENDING_ENANLED)
	// 加算
	half3 muvtex_add = diffuse2Amt.rgb * multi_uv_alpha;
	diffuseAmt.rgb += muvtex_add;
	#elif defined(MULTI_UV_MULTIPLICATIVE_BLENDING_ENANLED)
	// 乗算
	diffuseAmt.rgb = lerp(diffuseAmt.rgb, diffuseAmt.rgb * diffuse2Amt.rgb * BlendMulScale2, multi_uv_alpha);
	#elif defined(MULTI_UV_MULTIPLICATIVE_BLENDING_LM_ENANLED)
	// 乗算（ライトマップとして扱う）
//x	diffuseAmt.rgb = diffuseAmt.rgb * diffuse2Amt.rgb * BlendMulScale2;	// キューブマップ後まで遅らせる
	#elif defined(MULTI_UV_MULTIPLICATIVE_BLENDING_EX_ENANLED)
	// 乗算（純粋な掛け算。海や雲の揺らぎ表現に使う）
	diffuseAmt *= diffuse2Amt * BlendMulScale2;
	#else
	// アルファ
	diffuseAmt.rgb = lerp(diffuseAmt.rgb, diffuse2Amt.rgb, multi_uv_alpha);
	#endif

	// マルチUV2
	#if defined(MULTI_UV2_ENANLED)
		#if defined(DUDV_MAPPING_ENABLED)
	half4 diffuse3Amt = _h4tex2D(DiffuseMap3SamplerSampler, DiffuseMap3Sampler, IN.TexCoord3.xy + dudvValue);
		#else
	half4 diffuse3Amt = _h4tex2D(DiffuseMap3SamplerSampler, DiffuseMap3Sampler, IN.TexCoord3.xy);
		#endif
	half multi_uv2_alpha = half(IN.Color0.a) * diffuse3Amt.a;
		#if defined(MULTI_UV2_ADDITIVE_BLENDING_ENANLED)
	// 加算
	half3 muvtex_add2 = diffuse3Amt.rgb * multi_uv2_alpha;
	diffuseAmt.rgb += muvtex_add2;
		#elif defined(MULTI_UV2_MULTIPLICATIVE_BLENDING_ENANLED)
	// 乗算
	diffuseAmt.rgb = lerp(diffuseAmt.rgb, diffuseAmt.rgb * diffuse3Amt.rgb * BlendMulScale3, multi_uv2_alpha);
		#elif defined(MULTI_UV2_MULTIPLICATIVE_BLENDING_LM_ENANLED)
	// 乗算（ライトマップとして扱う）
//x	diffuseAmt.rgb = diffuseAmt.rgb * diffuse3Amt.rgb * BlendMulScale3;	// キューブマップ後まで遅らせる
		#elif defined(MULTI_UV2_MULTIPLICATIVE_BLENDING_EX_ENANLED)
	// 乗算（純粋な掛け算。海や雲の揺らぎ表現に使う）
	diffuseAmt *= diffuse3Amt * BlendMulScale3;
		#else
	// アルファ
	diffuseAmt.rgb = lerp(diffuseAmt.rgb, diffuse3Amt.rgb, multi_uv2_alpha);
		#endif
	#endif // defined(MULTI_UV2_ENANLED)
#endif // defined(MULTI_UV_ENANLED)

	// シャドウマップ
#if defined(RECEIVE_SHADOWS) && (defined(FP_DEFAULT) || defined(FP_FORCETRANSPARENT))
	half shadowValue = 1;
	float3 fakeWorldPos = IN.WorldPositionDepth.xyz + Light0.m_direction * SHADOW_LIGHTDIR_BIAS + IN.Normal.xyz * SHADOW_NORMALDIR_BIAS;
	half shadowMin = EvaluateShadow(LightShadow0, LightShadowMap0, fakeWorldPos, IN.WorldPositionDepth.w);
	// 影濃度のバイアス値を求める
	half shadowDensityBias = EvaluateShadowDensityBias_Depth(LightShadow0, IN.WorldPositionDepth.w);
	shadowDensityBias += EvaluateShadowDensityBias_Height(IN.WorldPositionDepth.y);
	shadowDensityBias += EvaluateShadowDensityBias_Angle_Map(IN.Normal.xyz, Light0.m_direction);
	shadowDensityBias = min(1, shadowDensityBias);
	shadowMin = min(shadowMin + shadowDensityBias, 1);
	shadowValue = min(shadowValue, shadowMin);
	#if defined(FP_DUDV_AMT_EXIST)
	shadowValue = (shadowValue + 1.0) * 0.5;
	#endif
#else // defined(RECEIVE_SHADOWS) && (defined(FP_DEFAULT) || defined(FP_FORCETRANSPARENT))
	half shadowValue = 1;
#endif // defined(RECEIVE_SHADOWS) && (defined(FP_DEFAULT) || defined(FP_FORCETRANSPARENT))

	// "雲の影"の濃度を加味
#if defined(PROJECTION_MAP_ENABLED)
	half4 projTex = _h4tex2D(LinearWrapSamplerState, ProjectionMapSampler, IN.ProjMap.xy);
//	shadowValue = max(shadowValue - (1 - (projTex.r * projTex.a)), 0);
	shadowValue = min(shadowValue, 1 - (projTex.r * projTex.a));
#endif // defined(PROJECTION_MAP_ENABLED)

	// シーン単位の影濃度を加味
	shadowValue += (1 - shadowValue) * (1 - half(scene.MiscParameters2.w));

	// モデル単位の影濃度を加味
	shadowValue += (1 - shadowValue) * (1 - half(GameMaterialEmission.a));

	// スペキュラマップ
#if defined(SPECULAR_MAPPING_ENABLED) || (defined(MULTI_UV_ENANLED) && defined(MULTI_UV_SPECULAR_MAPPING_ENABLED))
	half glossValue = 1;
	#if defined(SPECULAR_MAPPING_ENABLED)
	glossValue = _h4tex2D(SpecularMapSamplerSampler, SpecularMapSampler, IN.TexCoord.xy).x;
	#endif
	#if defined(MULTI_UV_ENANLED) && defined(MULTI_UV_SPECULAR_MAPPING_ENABLED)
	half glossValue2 = _h4tex2D(SpecularMap2SamplerSampler, SpecularMap2Sampler, IN.TexCoord2.xy).x;
	glossValue = lerp(glossValue, glossValue2, multi_uv_alpha);
	#endif
#else // defined(SPECULAR_MAPPING_ENABLED) || (defined(MULTI_UV_ENANLED) && defined(MULTI_UV_SPECULAR_MAPPING_ENABLED))
	half glossValue = 1;
#endif // defined(SPECULAR_MAPPING_ENABLED) || (defined(MULTI_UV_ENANLED) && defined(MULTI_UV_SPECULAR_MAPPING_ENABLED))

	// リムライト用のライト色を計算
#if defined(USE_LIGHTING) && (defined(RIM_LIGHTING_ENABLED) || defined(SHADOW_COLOR_SHIFT_ENABLED))
	half3 subLightColor = Light0.m_colorIntensity;
	#if defined(SPECULAR_MAPPING_ENABLED)
	subLightColor *= (glossValue + 1.0) * 0.5;
	#endif
	subLightColor *= pow(shadowValue, 2);
#else // defined(USE_LIGHTING) && defined(RIM_LIGHTING_ENABLED)
	half3 subLightColor = half3(0.0);
#endif // defined(USE_LIGHTING) && defined(RIM_LIGHTING_ENABLED)

	half4 resultColor = diffuseAmt;
	half3 shadingAmt;

	// 法線の算出
	float3 worldSpaceNormal = EvaluateNormalFP(IN);
#if defined(MULTI_UV_ENANLED) && defined(MULTI_UV_NORMAL_MAPPING_ENABLED)
	worldSpaceNormal = normalize(lerp(worldSpaceNormal, EvaluateNormal2FP(IN), multi_uv_alpha));
#endif

	// 視線ベクトルの計算
	float3 worldSpaceEyeDirection = normalize(GetEyePosition() - IN.WorldPositionDepth.xyz);

	// 視線ベクトルとの内積（リムライト、スフィア／キューブマップで使用）
	half ndote = dot(worldSpaceNormal, worldSpaceEyeDirection);
#if defined(DOUBLE_SIDED) && defined(RIM_LIGHTING_ENABLED)
	if (ndote < 0)
	{
		ndote *= -1;
		worldSpaceNormal *= -1;
	}
#endif // defined(DOUBLE_SIDED) && defined(RIM_LIGHTING_ENABLED)

	// スフィア／キューブマップ
#if defined(SPHERE_MAPPING_ENABLED)
	float3 viewSpaceNormal = float3(_mul(float3x3(scene.View), worldSpaceNormal));
	half4 sphereMapColor = _h4tex2D(LinearClampSamplerState, SphereMapSampler, viewSpaceNormal.xy * 0.5 + half2(0.5, 0.5)).rgba;
#elif defined(CUBE_MAPPING_ENABLED)
	#if defined(WATER_SURFACE_ENABLED)
	// 「水面」時は上方向に補正を掛ける。映り込みをより綺麗に見せるため
	float3 cubeMapNormal = normalize(lerp(worldSpaceNormal, float3(0,1,0), 0.9));
	half4 cubeMapColor = _h4texCUBE(LinearClampSamplerState, CubeMapSampler, reflect(-worldSpaceEyeDirection, cubeMapNormal)).rgba;
	half cubeMapFresnel = pow(1.0 - max(0, dot(cubeMapNormal, worldSpaceEyeDirection)) * CubeMapFresnel, 3);
	#else
	half4 cubeMapColor = _h4texCUBE(LinearClampSamplerState, CubeMapSampler, reflect(-worldSpaceEyeDirection, worldSpaceNormal)).rgba;
	half cubeMapFresnel = 1.0 - max(0, ndote) * CubeMapFresnel;
	#endif
	resultColor.rgb = lerp(resultColor.rgb, cubeMapColor.rgb, half(CubeMapIntensity) * cubeMapFresnel * glossValue);
#endif // defined(SPHERE_MAPPING_ENABLED)

	// ライティング計算
#if defined(USE_LIGHTING)

	// 環境光の算出
	half3 ambientAmount;
	#if defined(ALPHA_BLENDING_ENABLED) && defined(USE_EXTRA_BLENDING)
	ambientAmount = half3(0);
	#else // defined(ALPHA_BLENDING_ENABLED) && defined(USE_EXTRA_BLENDING)
		#if defined(NO_MAIN_LIGHT_SHADING_ENABLED)
	ambientAmount = half3(0.0,0.0,0.0);
			#define FP_NEED_AFTER_MAX_AMBIENT
		#else
	ambientAmount = GetGlobalAmbientColor();
		#endif
	#endif // defined(ALPHA_BLENDING_ENABLED) && defined(USE_EXTRA_BLENDING)

	shadingAmt = EvaluateLightingPerPixel(IN.WorldPositionDepth.xyz, worldSpaceNormal, glossValue, 1, ambientAmount, worldSpaceEyeDirection);
	shadingAmt = lerp(shadingAmt, shadingAmt * scene.MiscParameters1, 1 - shadowValue);

	// リムライト
	#if defined(USE_LIGHTING) && defined(RIM_LIGHTING_ENABLED)
	half rimLightvalue = EvaluateRimLightValue(ndote);
		#if defined(RIM_TRANSPARENCY_ENABLED)
	resultColor.a *= 1 - rimLightvalue;
		#else
	shadingAmt += rimLightvalue * half3(RimLitColor) * subLightColor;
	shadingAmt = ClampRimLighting(shadingAmt);
		#endif
	#endif // defined(USE_LIGHTING) && defined(RIM_LIGHTING_ENABLED)

#else // defined(USE_LIGHTING)

	shadingAmt = EvaluateLightingPerVertexFP(glossValue, 1, half3(0, 0, 0), half3(1, 1, 1), half3(0, 0, 0));
	shadingAmt = lerp(shadingAmt, shadingAmt * scene.MiscParameters1, 1 - shadowValue);

#endif // defined(USE_LIGHTING)

#if defined(FP_NEED_AFTER_MAX_AMBIENT)
	shadingAmt = max(shadingAmt, GetGlobalAmbientColor());
#endif

	// ライトマップの反映
#if defined(MULTI_UV_ENANLED)
	#if defined(MULTI_UV_MULTIPLICATIVE_BLENDING_LM_ENANLED)
	resultColor.rgb = resultColor.rgb * diffuse2Amt.rgb * BlendMulScale2;
	#endif
	#if defined(MULTI_UV2_ENANLED)
		#if defined(MULTI_UV2_MULTIPLICATIVE_BLENDING_LM_ENANLED)
	resultColor.rgb = resultColor.rgb * diffuse3Amt.rgb * BlendMulScale3;
		#endif
	#endif
#endif

	// 反射・屈折画像との合成
	#if defined(WATER_SURFACE_ENABLED) || defined(DUDV_MAPPING_ENABLED) || defined(FP_FORCETRANSPARENT)
		#if defined(FP_FORCETRANSPARENT)
	float3 _viewSpaceNormal = float3(_mul(float3x3(scene.View), reflect(-worldSpaceEyeDirection, worldSpaceNormal)));
	screenUv.xy += (_viewSpaceNormal * scene.AlphaTestDirection).xy;
		#endif
	float2 refrUv = lerp(screenUv.xy, screenUvBase, scene.AdditionalShadowOffset) / screenUv.w;
	refrUv.y = 1 - refrUv.y;
	half4 refrColor = _h4tex2D(LinearClampSamplerState, RefractionTexture, refrUv);
		#if defined(FP_FORCETRANSPARENT)
	resultColor.rgb = lerp(refrColor.rgb, resultColor.rgb, resultColor.a * PointLightParams.w);
		#else
	resultColor.rgb = lerp(refrColor.rgb, resultColor.rgb, resultColor.a);
		#endif
		#if defined(WATER_SURFACE_ENABLED)
	float2 reflUv = screenUv.xy / screenUv.w;
	reflUv.y = 1 - reflUv.y;
	half4 reflColor = _h4tex2D(LinearClampSamplerState, ReflectionTexture, reflUv);
	half waterFresnel = pow(1.0 - max(0, dot(float3(0,1,0), worldSpaceEyeDirection)) * half(ReflectionFresnel), 3);
	resultColor.rgb = lerp(resultColor.rgb, reflColor.rgb, half(ReflectionIntensity) * waterFresnel);
		#endif
	#endif // defined(WATER_SURFACE_ENABLED) || defined(DUDV_MAPPING_ENABLED) || defined(FP_FORCETRANSPARENT)

	// 陰影カラーシフト
#if defined(SHADOW_COLOR_SHIFT_ENABLED)
	// [Not Toon] 表面下散乱のような使い方
	half3 subLightColor2 = max(half3(1, 1, 1), subLightColor * 2);
	shadingAmt.rgb += (half3(1, 1, 1) - min(half3(1, 1, 1), shadingAmt.rgb)) * half3(ShadowColorShift) * subLightColor2;
#endif

	// スフィアマップ（加算合成）
#if defined(SPHERE_MAPPING_ENABLED)
	resultColor.rgb += sphereMapColor.rgb * half(SphereMapIntensity) * half3(IN.Color0.rgb) * glossValue;
#endif

	shadingAmt *= half3(IN.Color0.rgb);

	// 自己発光度マップ（ライトやシャドウを打ち消す値という解釈）
#if defined(EMISSION_MAPPING_ENABLED)
	half4 emiTex = _h4tex2D(EmissionMapSamplerSampler, EmissionMapSampler, IN.TexCoord.xy);
	shadingAmt.rgb = lerp(shadingAmt.rgb, half3(1), half3(emiTex.r));
#endif

	// ライティング結果を反映
#if defined(BLEND_VERTEX_COLOR_BY_ALPHA_ENABLED)
	resultColor.rgb = lerp(shadingAmt, resultColor.rgb, resultColor.a);
#else
	#if defined(FP_FORCETRANSPARENT)
	resultColor.rgb = lerp(resultColor.rgb * shadingAmt, resultColor.rgb, (1 - PointLightParams.w) * scene.MiscParameters5.z);
	#else
	resultColor.rgb *= shadingAmt;
	#endif
#endif

	// シェーダ外部からのカラー操作
	resultColor *= half4(GameMaterialDiffuse);
	resultColor.rgb += half3(GameMaterialEmission.rgb) * calcEmissionBias(ndote);

#if defined(MULTIPLICATIVE_BLENDING_ENABLED)
	resultColor.rgb += max((1 - resultColor.rgb), 0) * (1.0 - shadowValue);
#endif

	// フォグ計算
#if defined(FOG_ENABLED)
	float fogValue = EvaluateFogColor(resultColor.rgb, IN.Color1.a, IN.WorldPositionDepth.xyz);
#endif

	// フォグ濃度とブルーム強度は反比例
#if defined(BLOOM_ENABLED)
	#if defined(FOG_ENABLED)
	float brightRatio = 1 - fogValue * BRIGHT_RANGE_RCP;
	brightRatio *= brightRatio;
	#else
	float brightRatio = 1;
	#endif
	brightRatio *= PointLightParams.z;
#endif

#if defined(SUBTRACT_BLENDING_ENABLED)
	resultColor.rgb = resultColor.rgb * resultColor.a;
#elif defined(MULTIPLICATIVE_BLENDING_ENABLED)
	resultColor.rgb = (1 - resultColor.rgb) * resultColor.a;
#endif

	// モノクロ変換
	resultColor.rgb = lerp(resultColor.rgb, dot(resultColor.rgb, half3(0.299, 0.587, 0.114)) * half3(scene.MonotoneMul.xyz) + half3(scene.MonotoneAdd.xyz), half(GameMaterialMonotone));

#if !defined(ALPHA_BLENDING_ENABLED) && !defined(FP_FORCETRANSPARENT)
	resultColor.a = 1.0;	// レンダーターゲットに描画したときに半透明α値を上書きしてしまうため(場合によってはPORTRAIT限定で)
#endif

	// 出力
#if defined(FP_FORCETRANSPARENT)
	return resultColor;
#elif defined(FP_DEFAULT)
	half4 resultColor2 = half4(0,0,0,0);
	#if defined(ALPHA_BLENDING_ENABLED)
	resultColor2 = resultColor;	// A成分に輝度を書き込む形でグローを実現している関係上、アルファを使用しているマテリアルではグロー不可
	#else // defined(ALPHA_BLENDING_ENABLED)
		#if defined(GLARE_ENABLED)
			#if defined(GLARE_MAP_ENABLED)
	half glowValue = _h4tex2D(GlareMapSamplerSampler, GlareMapSampler, IN.TexCoord.xy).x;
			#else
	half glowValue = 1;
			#endif
			#if defined(MULTI_UV_GLARE_MAP_ENABLED)
	glowValue *= _h4tex2D(GlareMap2SamplerSampler, GlareMap2Sampler, IN.TexCoord2.xy).x;
			#endif
			#if defined(BLOOM_ENABLED)
	resultColor2 = half4(resultColor.rgb, lerp(CalcBrightness(resultColor.rgb) * brightRatio, CalcGlowValue(glowValue * GlareIntensity), glowValue));
			#else
	resultColor2 = half4(resultColor.rgb, CalcGlowValue(glowValue * GlareIntensity));
			#endif
		#else // defined(GLARE_ENABLED)
			#if defined(BLOOM_ENABLED)
	resultColor2 = half4(resultColor.rgb, CalcBrightness(resultColor.rgb) * brightRatio);
			#else
	resultColor2 = half4(resultColor.rgb, 0);
			#endif
		#endif // defined(GLARE_ENABLED)
	#endif // defined(ALPHA_BLENDING_ENABLED)
	#if defined(USE_MRT)
	// MRTが有効なら色以外の情報も出力
	DefaultFPOutputMRT resultMRT;
	resultMRT.Color = resultColor2;
	resultMRT.Normal = float4(encodeNormal(worldSpaceNormal), encodeVelocity(float2(0, 0)));
	uint mask = GBUF_MASK_NONE;
		#if defined(NO_SSAO)
	mask |= GBUF_MASK_NO_SSAO;
		#endif
		#if defined(NO_DYNAMIC_LIGHT)
	mask |= GBUF_MASK_NO_LIGHT;
		#endif
	resultMRT.Depth = float4(encodeDepth(IN.wvpPos.z / IN.wvpPos.w), encodeMask(mask));
	return resultMRT;
	#else // defined(USE_MRT)
	return resultColor2;
	#endif // defined(USE_MRT)
#endif // defined(FP_FORCETRANSPARENT)

#endif // defined(NOTHING_ENABLED)
}

in	DefaultVPOutput OUT;

#if defined(main_DefaultFPShader) && defined(USE_MRT)
layout (location = 0) out vec4 out_FragColor;
layout (location = 1) out vec4 out_FragNormal;
layout (location = 2) out vec4 out_FragDepth;
#else
out vec4 out_FragColor;
#endif

void main()
{
#if defined(main_DefaultFPShader)
	#if defined(USE_MRT)
	DefaultFPOutputMRT OUT_ = DefaultFPShader(OUT, gl_FragCoord);
	out_FragColor = OUT_.Color;
	out_FragNormal = OUT_.Normal;
	out_FragDepth = OUT_.Depth;
	#else
	out_FragColor = DefaultFPShader(OUT, gl_FragCoord);
	#endif
#elif defined(main_ForceTransparentFPShader)
	out_FragColor = ForceTransparentFPShader(OUT, gl_FragCoord);
#endif
}

#endif

//-------------------------------------------------------------------------------
// 強制半透明パス(深度値書き込み用）
//-------------------------------------------------------------------------------
#if defined(main_ForceTransparentDepthFPShader)
void ForceTransparentDepthFPShader(TransparentDepthVPOutput IN)
{
	half4 diffuseAmt = _h4tex2D(DiffuseMapSamplerSampler, DiffuseMapSampler, IN.TexCoord.xy);

	// アルファテスト
#if defined(ALPHA_BLENDING_ENABLED) || defined(ALPHA_TESTING_ENABLED)
	#if defined(ALPHA_TESTING_ENABLED)
	clip(diffuseAmt.a - AlphaThreshold * half(IN.Color0.a));
	#else
	clip(diffuseAmt.a - 0.004);
	#endif
#endif // defined(ALPHA_BLENDING_ENABLED) || defined(ALPHA_TESTING_ENABLED)
}

in	TransparentDepthVPOutput OUT;

void main()
{
	ForceTransparentDepthFPShader(OUT);
}
#endif
