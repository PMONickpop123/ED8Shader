
uniform sampler2D LowResDepthTexture;
uniform sampler2D DitherNoiseTexture;

#define FPS_MAX	30

struct DirectionalLight
{
	half3 m_direction;
	half3 m_colorIntensity;
};

// 影受けバイアス値
#define SHADOW_LIGHTDIR_BIAS	0.05
#define SHADOW_NORMALDIR_BIAS	0.05

// カスケードシャドウマップ分割数（アプリ側のコードと合わせること！）
	#define MAX_SPLIT_CASCADED_SHADOWMAP	2
	#define PCF_ENABLED

struct CombinedCascadedShadowMap
{
#if (MAX_SPLIT_CASCADED_SHADOWMAP == 1)

	// 分割無し
	float4x4 m_split0Transform;

#elif (MAX_SPLIT_CASCADED_SHADOWMAP == 2)

	// 二分割
	float4x4 m_split0Transform;
	float4x4 m_split1Transform;

#endif // (MAX_SPLIT_CASCADED_SHADOWMAP == 1)

	float4 m_splitDistances;
};

//------------------------------------------------------------------------------
//プログラム入力変数
//------------------------------------------------------------------------------

uniform sampler2D	DepthBuffer;
uniform sampler2D	TextureSampler;
uniform sampler2D	Texture1Sampler;
uniform sampler2D	Texture2Sampler;

layout(std140) uniform Param
{
uniform SceneWideParameters scene;

uniform float4x4 World;
uniform float4x4 WorldView;
uniform float4x4 WorldViewProjection;
uniform float4x4 WorldViewInverse;	
uniform float4x4 WorldViewProjectionInverse;	
uniform float4x4 WorldInverse;

uniform float 		CameraAspectRatio;
uniform float4 		inputColor;					// 色
uniform float4 		inputSpecular;					// スペキュラ
uniform float		inputAlphaThreshold;								// αテストのしきい値(Vitaではαテストをシェーダーでやる必要ある）
uniform float4		inputCenter;
uniform float4		inputUVShift;								// UVずらし値
uniform float4		inputUVShift1;								// UVずらし値(2マルチ）
uniform float4		inputUVShift2;								// UVずらし値(3マルチ）
uniform float2		inputUVtraspose;							// UV転置用
uniform float2		inputUVtraspose1;							// UV転置用(2マルチ）
uniform float2		inputUVtraspose2;							// UV転置用(3マルチ）
uniform float4		inputShaderParam;					// リムパラム
uniform float2		inputDUDVParam1;
uniform float2		inputScreenOffset;							// 3D描画でのスクリーン座標オフセット
uniform float		inputDepth;
uniform float2		inputSoftCheckDepthParam;					// ソフトシェーダーパラム
uniform float3		inputNearFadeClip;							// ニアフェードクリップ
uniform float		inputDownscaleFactor;
uniform float2		inputDepthBufferSize;
uniform float2		inputDistortion;							// 光学歪み（法線、UV）
uniform float3		inputBlurParam;						// 3D_ZOOM_BLUR の中心
uniform float4 		inputMonotoneMul;				// モノトーンフィルタ RGB:色 A:補間
uniform float4 		inputMonotoneAdd;				// モノトーンフィルタ RGB:色 A:-
uniform float4		inputInvProjXY;
uniform float3		inputDirectionalLightVec;			// 平行光源
uniform float4		inputDirectina_Ligh_Color;	// 平行光源(RGBI)	Directional, Light Color といった単語は禁句らしい。コンバート結果に含まれない
uniform float4		inputAmbientColor;			// 環境光RGBA)

uniform float4 		GameDitherParams;	// x = Near, y = 1 / (Far - Near), z = Far, w = 未使用
};
	
// fxファイルとの互換性を高めるため構造体型の入出力にしました
struct SpriteC_VPInput
{
	float3 position;
	float4 color;
};
	
struct SpriteC_VPOutput
{
	float4 position;
	float4 color;
};

struct SpriteCT_VPInput
{
	float3 position;
	float4 color;
	float2 texCoord;
};

struct SpriteCT_VPOutput
{
	float4 position;
	float4 color;
	float2 texCoord;
};

struct SpriteCT_VPOutput_Soft
{
	float4 position;
	float4 color;
	float2 texCoord;
	float4 projPos;
};

struct SpriteCT2DMT_VPOutput
{
	float4 position;
	float4 color;
	float2 texCoord0;
	float2 texCoord1;
	float2 texCoord2;
};
	

	

struct SpriteCT3D_VPOutput
{
	float4 position;
	float4 color;
	float4 specular;
	
	float2 texCoord;
	float4 texCoord1;
	
#if defined(CS_PARTICLE_DITHER_ENABLE)
	half4 ditherParam;
#endif
};

//-----------------------------------------------------------------------------
// 視点の位置
//-----------------------------------------------------------------------------
float3 getEyePosition()
{
//#ifdef DCC_TOOL
//	return float3(ViewIXf[0].w, ViewIXf[1].w, ViewIXf[2].w);
//#else // DCC_TOOL
	return float3(scene.EyePosition);
//#endif // DCC_TOOL
}

//------------------------------------------------------------------------------
// 仮想陰影値を計算
// pos:頂点ワールド座標
//------------------------------------------------------------------------------
float getShadeFactor(float3 worldPos )
{
	float dh		= worldPos.y - inputCenter.y;
	
	dh += inputCenter.w;			//w==0で初期値が動くように

	dh = clamp(dh, 0.0, 1.0);
	

	return dh;
}

//------------------------------------------------------------------------------
// 画面手前フェード消し(頂点単位)
//------------------------------------------------------------------------------
float getNearFadeFactor( float projectionSpaceZ )
{
	// 無効のときは1を返す
	float nearClipDistanceBegin = inputNearFadeClip.x;	//4.0;	//消え始めのカメラからの距離
	float nearClipDistanceEnd = inputNearFadeClip.y;	//2.0;	//消え終わりカメラからの距離
	projectionSpaceZ = max(projectionSpaceZ,0.0);
	float w = max(nearClipDistanceBegin - nearClipDistanceEnd, 0.0);
	float rate = (w <= 0.00) ? 1.0 : (projectionSpaceZ - nearClipDistanceEnd) / w;
	return saturate(rate);
}


//-----------------------------------------------------------------------------
// DepthバッファからDepth値を
//-----------------------------------------------------------------------------
float ReadDepth( sampler2D depthMap, float2 uv )
{
	float currentDepth = _tex2D(PointClampSamplerState, depthMap, uv.xy).x;
	return currentDepth;
}

//-----------------------------------------------------------------------------
// 深度バッファから深度値を得る
//-----------------------------------------------------------------------------
float GetScreenSpaceDepth( sampler2D depthBuffer, float2 uv )
{
	uv.xy *= float2(inputDownscaleFactor, inputDownscaleFactor);	
	
	// 描画先の奥行き値
	return ReadDepth( depthBuffer, uv.xy );
}
	
//------------------------------------------------------------------------------
// Convert a depth value from post projection space to view space. 
//------------------------------------------------------------------------------
float ConvertDepth(float depth)
{	
#ifdef ORTHO_CAMERA
	float viewSpaceZ = -(depth * scene.cameraFarMinusNear + scene.cameraNearFar.x);
#else //! ORTHO_CAMERA
	float viewSpaceZ = -(scene.cameraNearTimesFar / (depth * scene.cameraFarMinusNear - scene.cameraNearFar.y));
#endif //! ORTHO_CAMERA
	return viewSpaceZ;
}
//------------------------------------------------------------------------------
// 転置UVを返す
// inputUVtraspose = {1,0} で通常UV {0,1}で転置
//------------------------------------------------------------------------------
float2 getUV( float2 IN )
{
	// UV転置
	float2 OUT;
	float2 uv1 = IN * inputUVShift.xy + inputUVShift.zw;
	OUT.x = uv1.x * inputUVtraspose.x + uv1.y *-inputUVtraspose.y + 1 * inputUVtraspose.y;
	OUT.y = uv1.y * inputUVtraspose.x + uv1.x * inputUVtraspose.y;
	return OUT;
}
float2 getUV1( float2 IN )
{
	// UV転置
	float2 OUT;
	float2 uv1 = IN * inputUVShift1.xy + inputUVShift1.zw;
	OUT.x = uv1.x * inputUVtraspose1.x + uv1.y *-inputUVtraspose1.y + 1 * inputUVtraspose1.y;
	OUT.y = uv1.y * inputUVtraspose1.x + uv1.x * inputUVtraspose1.y;
	return OUT;
}
float2 getUV2( float2 IN )
{
	// UV転置
	float2 OUT;
	float2 uv1 = IN * inputUVShift2.xy + inputUVShift2.zw;
	OUT.x = uv1.x * inputUVtraspose2.x + uv1.y *-inputUVtraspose2.y + 1 * inputUVtraspose2.y;
	OUT.y = uv1.y * inputUVtraspose2.x + uv1.x * inputUVtraspose2.y;
	return OUT;
}
	
//------------------------------------------------------------------------------
// スクリーン座標のディザUVを取得
//------------------------------------------------------------------------------
float GetDitherThreshold(float2 screenPos)
{
	float2 matrixUv = screenPos * (1.0/4);
	return _tex2Dlod(PointWrapSamplerState, DitherNoiseTexture, matrixUv, 0).x;
}
	
//------------------------------------------------------------------------------
// 深度からディザレベルを取得
//------------------------------------------------------------------------------
float EvaluateDitherValue(float3 viewPosition, float n, float r)
{
	float t = saturate((-viewPosition.z - n) * r);
	return 1 - t;
}
	
//-----------------------------------------------------------------------------
// インスタンシング
//-----------------------------------------------------------------------------
#if defined(INSTANCING_ENABLED)
	struct InstancingInput
	{
		float4 InstanceTransform0;
		float4 InstanceTransform1;
		float4 InstanceTransform2;
		float4 InstanceColor;
	};
layout (location = 12) in InstancingInput instancingInput;

void ApplyInstanceTransformVertex(InstancingInput IN, inout float3 toTransform)
{
	float3 instanceTransformedPosition;
	instanceTransformedPosition.x = dot(IN.InstanceTransform0, float4(toTransform,1));
	instanceTransformedPosition.y = dot(IN.InstanceTransform1, float4(toTransform,1));
	instanceTransformedPosition.z = dot(IN.InstanceTransform2, float4(toTransform,1));
	toTransform = instanceTransformedPosition;
}

void ApplyInstanceTransformNormal(InstancingInput IN, inout float3 toTransform)
{
	float3 instanceTransformedNormal;
	instanceTransformedNormal.x = dot(IN.InstanceTransform0.xyz, toTransform);
	instanceTransformedNormal.y = dot(IN.InstanceTransform1.xyz, toTransform);
	instanceTransformedNormal.z = dot(IN.InstanceTransform2.xyz, toTransform);
	toTransform = instanceTransformedNormal;
}
// colorからcolorとspecularを抜き出す
void ApplyInstanceColorSpecular(inout float4 color, out float4 specular)
{
	float4 col = float4(1,1,1,1);
	float4 spe = modf(color, col);	// 小数部spe, 整数部col
	color = col / 100000.0;
	specular = spe * 10.0;
}

#endif 	// INSTANCING_ENABLED
	
///////////////////////////////////////////////////////////////////////////////
// スプライト

#ifdef main_PositionColor2D_VP
SpriteC_VPOutput PositionColor2D_VP(SpriteC_VPInput IN)
{
	SpriteC_VPOutput OUT;
	float4 localPosition = float4(IN.position.xyz,1.0);	
	OUT.position = _mul(World, localPosition);
	OUT.position.x *= CameraAspectRatio;
	OUT.color = IN.color;
	return OUT;
}

in	SpriteC_VPInput IN;
out	SpriteC_VPOutput OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	OUT = PositionColor2D_VP(IN);

	gl_Position		= OUT.position;
}
#endif

#ifdef main_PositionColor2D_FP
half4 PositionColor2D_FP(SpriteC_VPOutput IN)
{
	return IN.color;
}

in	SpriteC_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionColor2D_FP(OUT);
}
#endif

//-----------------------------------------------------------------------------
// 頂点シェーダー：2D, 標準、マルチテクスチャ
//-----------------------------------------------------------------------------
#ifdef main_PositionTextureColor2DMT_VP
SpriteCT2DMT_VPOutput PositionTextureColor2DMT_VP(SpriteCT_VPInput IN)
{
	SpriteCT2DMT_VPOutput OUT;
	float4 localPosition = float4(IN.position.xyz,1.0);	
	OUT.position = _mul(World, localPosition);
	OUT.position.x *= CameraAspectRatio;
	OUT.color     = IN.color    * inputColor;
	OUT.texCoord0 = IN.texCoord * inputUVShift.xy + inputUVShift.zw;
	OUT.texCoord1 = IN.texCoord * inputUVShift1.xy + inputUVShift1.zw;
	OUT.texCoord2 = float2(0);
	return OUT;
}

in	SpriteCT_VPInput IN;
out	SpriteCT2DMT_VPOutput OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	OUT = PositionTextureColor2DMT_VP(IN);

	gl_Position		= OUT.position;
}
#endif

//-----------------------------------------------------------------------------
// フラグメントシェーダー：2D, 標準、マルチテクスチャ
//-----------------------------------------------------------------------------
#ifdef main_PositionTextureColor2DMT_FP
half4 PositionTextureColor2DMT_FP(SpriteCT2DMT_VPOutput IN)
{
	float4 _color0 = _tex2D(VariableSamplerState, TextureSampler, IN.texCoord0);
	float4 _color1 = _tex2D(VariableSamplerState1, Texture1Sampler, IN.texCoord1);
	_color0 *= IN.color;
	_color0.rgb += inputSpecular.rgb * inputSpecular.a;
	_color0.a = min(1.0, _color0.a * _color1.r * _color1.a);
	return _color0;
}

in	SpriteCT2DMT_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionTextureColor2DMT_FP(OUT);
}
#endif

//-----------------------------------------------------------------------------
// 頂点シェーダー：2D, 標準
//-----------------------------------------------------------------------------
#ifdef main_PositionTextureColor2D_VP
SpriteCT_VPOutput PositionTextureColor2D_VP(SpriteCT_VPInput IN)
{
	SpriteCT_VPOutput OUT;
	float4 localPosition = float4(IN.position.xyz,1.0);	
	OUT.position = _mul(World, localPosition);
	OUT.position.x *= CameraAspectRatio;
	OUT.position.z = inputDepth;	//Z値書き込みたい場合に使う
	OUT.texCoord = IN.texCoord * inputUVShift.xy + inputUVShift.zw;
	OUT.color    = IN.color    * inputColor;
	return OUT;
}

in	SpriteCT_VPInput IN;
out	SpriteCT_VPOutput OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	OUT = PositionTextureColor2D_VP(IN);

	gl_Position		= OUT.position;
}
#endif
//-----------------------------------------------------------------------------
// フラグメントシェーダー：2D, 標準
//-----------------------------------------------------------------------------
#ifdef main_PositionTextureColor2D_FP
half4 PositionTextureColor2D_FP(SpriteCT_VPOutput IN)
{
	float4 _color = _tex2D(VariableSamplerState, TextureSampler, IN.texCoord);
	_color *= IN.color;
	_color.rgb += inputSpecular.rgb * inputSpecular.a;
	return _color;
}

in	SpriteCT_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionTextureColor2D_FP(OUT);
}
#endif

#ifdef main_PositionTextureColorMonotone2D_FP
half4 PositionTextureColorMonotone2D_FP(SpriteCT_VPOutput IN)
{
	float4 _color = _tex2D(VariableSamplerState, TextureSampler, IN.texCoord);
	_color *= IN.color;
	_color.rgb += inputSpecular.rgb * inputSpecular.a;
	float3 mono = dot(_color.rgb, float3(0.299, 0.587, 0.114)) * inputMonotoneMul.rgb + inputMonotoneAdd.rgb;
	_color.rgb = lerp(_color.rgb, mono, inputMonotoneMul.a);
	return half4(_color);
}

in	SpriteCT_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionTextureColorMonotone2D_FP(OUT);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// ポリゴン

// 位置、色
#ifdef main_PositionColor3D_VP
SpriteC_VPOutput PositionColor3D_VP(SpriteC_VPInput IN)
{
	SpriteC_VPOutput OUT;
	float4 localPosition = float4(IN.position.xyz,1.0);	
	OUT.position = _mul(WorldViewProjection, localPosition);
	OUT.color    = IN.color    * inputColor;
	return OUT;
}

in	SpriteC_VPInput IN;
out	SpriteC_VPOutput OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	OUT = PositionColor3D_VP(IN);

	gl_Position		= OUT.position;
}
#endif

#ifdef main_PositionColor3D_FP
half4 PositionColor3D_FP(SpriteC_VPOutput IN)
{
	return IN.color;
}

in	SpriteC_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionColor3D_FP(OUT);
}
#endif

//-----------------------------------------------------------------------------
// 頂点シェーダー：3D, 標準
//-----------------------------------------------------------------------------
// 位置、テクスチャ、色		(FVF_POSITION|FVF_TEXCOORD0|FVF_COLOR0)
#ifdef main_PositionTextureColor3D_VP
SpriteCT_VPOutput PositionTextureColor3D_VP(SpriteCT_VPInput IN)
{
	SpriteCT_VPOutput OUT;
	float4 localPosition = float4(IN.position.xyz,1.0);	
	OUT.position = _mul(WorldViewProjection, localPosition);
	OUT.texCoord = getUV( IN.texCoord );
	OUT.color    = IN.color    * inputColor;

	//陰影
	float4 worldPos = _mul(World, localPosition);
	OUT.color.a *= getShadeFactor( worldPos.xyz );

	OUT.color.a *= getNearFadeFactor( OUT.position.z );
	return OUT;
}

in	SpriteCT_VPInput IN;
out	SpriteCT_VPOutput OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	OUT = PositionTextureColor3D_VP(IN);

	gl_Position		= OUT.position;
}
#endif

//-----------------------------------------------------------------------------
// フラグメントシェーダー：3D, 標準
//-----------------------------------------------------------------------------
#ifdef main_PositionTextureColor3D_FP
half4 PositionTextureColor3D_FP(SpriteCT_VPOutput IN)
{
	float4 _color = _tex2D(VariableSamplerState, TextureSampler, IN.texCoord);
	
	_color *= IN.color;

	_color.rgb += inputSpecular.rgb * inputSpecular.a;

	clip(_color.a - inputAlphaThreshold);	//αテスト(Vitaで必要)

	return _color;
}

in	SpriteCT_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionTextureColor3D_FP(OUT);
}
#endif

//-----------------------------------------------------------------------------
// 頂点シェーダー：3D,ソフトパーティクル 標準
//-----------------------------------------------------------------------------
// 位置、テクスチャ、色		(FVF_POSITION|FVF_TEXCOORD0|FVF_COLOR0)
#ifdef main_PositionTextureColor3D_Soft_VP
SpriteCT_VPOutput_Soft PositionTextureColor3D_Soft_VP(SpriteCT_VPInput IN)
{
	SpriteCT_VPOutput_Soft OUT;
	float4 localPosition = float4(IN.position.xyz,1.0);	
	OUT.position = _mul(WorldViewProjection, localPosition);
	OUT.texCoord = getUV( IN.texCoord );
	OUT.color    = IN.color    * inputColor;
	OUT.projPos = OUT.position;

	//陰影
	float4 worldPos = _mul(World, localPosition);
	OUT.color.a *= getShadeFactor( worldPos.xyz );

	OUT.color.a *= getNearFadeFactor( OUT.position.z );
	return OUT;
}

in	SpriteCT_VPInput IN;
out	SpriteCT_VPOutput_Soft OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	OUT = PositionTextureColor3D_Soft_VP(IN);

	gl_Position		= OUT.position;
}
#endif

//-----------------------------------------------------------------------------
// フラグメントシェーダー：3D,ソフトパーティクル 標準
//-----------------------------------------------------------------------------
#ifdef main_PositionTextureColor3D_Soft_FP
half4 PositionTextureColor3D_Soft_FP(SpriteCT_VPOutput_Soft IN)
{
	float4 _color = _tex2D(VariableSamplerState, TextureSampler, IN.texCoord);
	
	_color *= IN.color;

	_color.rgb += inputSpecular.rgb * inputSpecular.a;

	clip(_color.a - inputAlphaThreshold);	//αテスト(Vitaで必要)
	
	float2 screenPos = (IN.projPos.xy / IN.projPos.w);
	float depthBuf = GetScreenSpaceDepth(DepthBuffer, screenPos * 0.5 + 0.5 );						// (-1.0～1.0) -> (0.0～1.0)
	
	// 描画する物の奥行き値
#if defined(PHYRE_D3DFX)
	float depthVal = (IN.projPos.z / IN.projPos.w);									// 0 - 1
#else
	float depthVal = (IN.projPos.z / IN.projPos.w) * 0.5 + 0.5;						// 0 - 1
#endif
	
	// ViewSpaceZ(m) に変換
	depthBuf = ConvertDepth(depthBuf);
	depthVal = ConvertDepth(depthVal);

	float fadeWidth = inputSoftCheckDepthParam.x;
	float depthDelta = (depthBuf - depthVal);
	float alphaA = depthDelta / fadeWidth;																							// 深度値が近い場合消す
	float alphaB = (depthBuf > depthVal) ? (1 - ((depthBuf - depthVal) / fadeWidth)) : (1 - ((depthVal - depthBuf) / fadeWidth));	// 深度値からプラス方向マイナス方向に消す
	
	float alpha = alphaA * (1-inputSoftCheckDepthParam.y) + alphaB * inputSoftCheckDepthParam.y;									// alphaA か alphaB 片方のみ有効にする

	alpha = saturate(alpha);
	_color.a *= alpha;

	return _color;
}

in	SpriteCT_VPOutput_Soft OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionTextureColor3D_Soft_FP(OUT);
}
#endif

//------------------------------------------------------------------------------
// 入力頂点 FVF_3D3   FVF_POSITION|FVF_NORMAL|FVF_TEXCOORD0|FVF_COLOR0
//------------------------------------------------------------------------------
struct DefualtVPInput
{
	float3 position;
	float3 normal;
	float2 texCoord;
	float4 color;
	
#ifdef INSTANCING_ENABLED
	InstancingInput instancingInput;
#endif
};


//------------------------------------------------------------------------------
// 頂点シェーダー：3D,通常,法線あり
//------------------------------------------------------------------------------
#ifdef main_PositionNormalTextureColor3D_VP
SpriteCT_VPOutput PositionNormalTextureColor3D_VP( DefualtVPInput IN )
{
	SpriteCT_VPOutput OUT;

	float4 localPosition = float4(IN.position.xyz,1.0);	
	OUT.position = _mul(WorldViewProjection, localPosition);

	// UV転置
	OUT.texCoord = getUV( IN.texCoord );	
	OUT.color    = IN.color    * inputColor;
	OUT.color.a *= getNearFadeFactor( OUT.position.z );

	//陰影
	float4 worldPos = _mul(World, localPosition);
	OUT.color.a *= getShadeFactor( worldPos.xyz );

	//スクリーン座標系でのオフセット(-1～1)
	OUT.position.xy += inputScreenOffset.xy * OUT.position.ww;
	return OUT;
};

in	DefualtVPInput IN;
out	SpriteCT_VPOutput OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	DefualtVPInput IN_ = IN;
#ifdef INSTANCING_ENABLED
	IN_.instancingInput	= instancingInput;
#endif

	OUT = PositionNormalTextureColor3D_VP(IN_);

	gl_Position		= OUT.position;
}
#endif
	
//------------------------------------------------------------------------------
// リム透明度を計算
//------------------------------------------------------------------------------
half getRimAlphaFactor( half alpha )
{	
	// 切り替え部分（線形補完）
	// start + ((end - start) * s);
	
	half4 param = half4(inputShaderParam);

	// αを強くする
	half outsideAlpha = pow(max(0, 1.0 - alpha), param[0] );
	outsideAlpha *= param[1];
	outsideAlpha = saturate(outsideAlpha);

	// 外側／内側切り替え
	half insideAlpha = 1.0 - outsideAlpha;	
	half rimAlpha = insideAlpha + ((outsideAlpha - insideAlpha) * param[2]);	// リム消しの外側／内側			inputShaderParam[2] == 1 のとき外側

	// 有効／無効切り替え（無効指定のときは、α=1を返す）
	rimAlpha = 1.0 + ((rimAlpha - 1.0) * param[3]);							// リム消しの有効／無効			inputShaderParam[3] == 1 のとき有効

	return rimAlpha;
}
	
//------------------------------------------------------------------------------
// 法線での歪み度を計算
//------------------------------------------------------------------------------
half getRimDistortionFactor( half alpha )
{	
	// αを強くする
	half outsideAlpha = pow(max(0, alpha), half(inputDistortion[0]) );
	outsideAlpha *= half(inputDistortion[0]);

	half rimAlpha = outsideAlpha;

	return rimAlpha;
}
	
//------------------------------------------------------------------------------
// 頂点シェーダー：3D,カメラに対して頂点単位で淵を消すシェーダー
//------------------------------------------------------------------------------
#ifdef main_PositionNormalTextureColor3D_rimTransparency_VP
SpriteCT_VPOutput PositionNormalTextureColor3D_rimTransparency_VP( DefualtVPInput IN )
{
	SpriteCT_VPOutput OUT;

	float4 localPosition = float4(IN.position.xyz,1.0);	
	OUT.position = _mul(WorldViewProjection, localPosition);

	float3 worldNormal   = _mul( World, float4(IN.normal.xyz,0)).xyz;
	float3 worldPosition = _mul(World, localPosition).xyz;

	//視線、法線で計算
	float3 cameraVec = normalize( getEyePosition() - worldPosition );
	float3 normalVec = normalize( worldNormal );	

	half alpha = abs( dot(cameraVec, normalVec) );
	
	alpha = getRimAlphaFactor(alpha);
		
	OUT.texCoord = getUV( IN.texCoord );	
	OUT.color    = IN.color * inputColor;
	OUT.color.a *= alpha;
	OUT.color.a *= getNearFadeFactor( OUT.position.z );
	return OUT;
};

in	DefualtVPInput IN;
out	SpriteCT_VPOutput OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	DefualtVPInput IN_ = IN;
#ifdef INSTANCING_ENABLED
	IN_.instancingInput	= instancingInput;
#endif

	OUT = PositionNormalTextureColor3D_rimTransparency_VP(IN_);

	gl_Position		= OUT.position;
}
#endif
	
//-----------------------------------------------------------------------------
// 頂点シェーダー：3D, スクリーンＵＶシェーダ
//-----------------------------------------------------------------------------
// 位置、テクスチャ、色		(FVF_POSITION|FVF_NORMAL|FVF_TEXCOORD0|FVF_COLOR0)
#ifdef main_PositionNormalTextureColor3D_ScreenUV_VP
SpriteCT3D_VPOutput PositionNormalTextureColor3D_ScreenUV_VP( DefualtVPInput IN)
{
	SpriteCT3D_VPOutput OUT;
	float4 localPosition = float4(IN.position.xyz,1.0);	
	OUT.position = _mul(WorldViewProjection, localPosition);
	
	float4 localNomal = float4(IN.normal.xyz,1.0);		
	float4 wvpNormal = _mul(WorldViewProjection, localNomal);

	float3 worldPosition = _mul(World, localPosition).xyz;

	// 視線、法線で計算
	float3 cameraVec = normalize( getEyePosition() - worldPosition );
	
	float3 normalVec = normalize( _mul( World, float4(IN.normal.xyz,0)).xyz);
	half alpha = abs( dot(cameraVec, normalVec) );

	OUT.texCoord = getUV( IN.texCoord );	
	OUT.texCoord1 = OUT.position;	
	OUT.texCoord1 += wvpNormal * getRimDistortionFactor(alpha);
	
	alpha = float(getRimAlphaFactor(alpha));
	
	OUT.specular = inputSpecular;
	OUT.color    = IN.color * inputColor;
	OUT.color.a *= alpha;
	OUT.color.a *= getNearFadeFactor( OUT.position.z );
	
#if defined(CS_PARTICLE_DITHER_ENABLE)
	OUT.ditherParam = 0;
#endif
	return OUT;
}

in	DefualtVPInput IN;
out	SpriteCT3D_VPOutput OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	DefualtVPInput IN_ = IN;
#ifdef INSTANCING_ENABLED
	IN_.instancingInput	= instancingInput;
#endif

	OUT = PositionNormalTextureColor3D_ScreenUV_VP(IN_);

	gl_Position		= OUT.position;
}
#endif

//-----------------------------------------------------------------------------
// フラグメントシェーダー：3D, スクリーンＵＶシェーダ
//-----------------------------------------------------------------------------
#ifdef main_PositionTextureColor3D_ScreenUV_FP
half4 PositionTextureColor3D_ScreenUV_FP(SpriteCT3D_VPOutput IN)
{
	float4 uv1 = IN.texCoord1;
	uv1.xy = ((uv1.xy / uv1.w) * 0.5) + 0.5;
	uv1.xy += IN.texCoord * inputDistortion[1]; // UVの影響
	float4 _color = _tex2D(VariableSamplerState, TextureSampler, uv1.xy);
	_color *= IN.color;
	_color.rgb += IN.specular.rgb * IN.specular.a;
	clip(_color.a - inputAlphaThreshold);	//αテスト(Vitaで必要)
	return _color;
}

in	SpriteCT3D_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionTextureColor3D_ScreenUV_FP(OUT);
}
#endif

//-----------------------------------------------------------------------------
// フラグメントシェーダー：3D, スクリーンＵＶシェーダ
//-----------------------------------------------------------------------------
#ifdef main_PositionTextureColor3D_StealthUV_FP
half4 PositionTextureColor3D_StealthUV_FP(SpriteCT3D_VPOutput IN)
{
	float4 uv1 = IN.texCoord1;
	uv1.xy = ((uv1.xy / uv1.w) * 0.5) + 0.5;
	uv1.xy += IN.texCoord;					// 埋め込みUVでずらす
	float4 _color = _tex2D(VariableSamplerState, TextureSampler, uv1.xy);
	_color *= IN.color;
	_color.rgb += IN.specular.rgb * IN.specular.a;
	clip(_color.a - inputAlphaThreshold);	//αテスト(Vitaで必要)
	return _color;
}

in	SpriteCT3D_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionTextureColor3D_StealthUV_FP(OUT);
}
#endif

//-----------------------------------------------------------------------------
// 頂点シェーダー：3D, カットインＵＶシェーダ
// -0.5 ～ 0.5 の四角の頂点値をそのままUVとする。回転大きさを適用しても画像は回転しない。
//-----------------------------------------------------------------------------
// 位置、テクスチャ、色		(FVF_POSITION|FVF_NORMAL|FVF_TEXCOORD0|FVF_COLOR0)
#ifdef main_PositionNormalTextureColor3D_CutinUV_VP
SpriteCT3D_VPOutput PositionNormalTextureColor3D_CutinUV_VP( DefualtVPInput IN)
{
	SpriteCT3D_VPOutput OUT;
	float4 localPosition = float4(IN.position.xyz,1.0);	
	float3 worldPosition = _mul(World, localPosition).xyz;
	float4 uv1 = float4( worldPosition, 1.0 );
	uv1.xyz -= float3(World[0].w, World[1].w, World[2].w);
	
	//(テクスチャアスペクト比、倍率(0.5)、上下反転, 0)
	uv1.xy *= inputShaderParam[1];
	float aspect = inputShaderParam[0];
	uv1.x *= aspect;
	
	uv1.xy = uv1.xy * 2.0;		// 0.5 -> 1.0
	
	OUT.position = _mul(WorldViewProjection, localPosition);
	OUT.specular = inputSpecular;
	OUT.color    = IN.color * inputColor;
	OUT.texCoord = float2(0.0);	
	OUT.texCoord1 = uv1;
	
#if defined(CS_PARTICLE_DITHER_ENABLE)
	OUT.ditherParam = 0;
#endif
	return OUT;
}

in	DefualtVPInput IN;
out	SpriteCT3D_VPOutput OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	DefualtVPInput IN_ = IN;
#ifdef INSTANCING_ENABLED
	IN_.instancingInput	= instancingInput;
#endif

	OUT = PositionNormalTextureColor3D_CutinUV_VP(IN_);

	gl_Position		= OUT.position;
}
#endif

//-----------------------------------------------------------------------------
// フラグメントシェーダー：3D, カットインＵＶシェーダ
//-----------------------------------------------------------------------------
#ifdef main_PositionTextureColor3D_CutinUV_FP
half4 PositionTextureColor3D_CutinUV_FP(SpriteCT3D_VPOutput IN)
{
	float4 uv1 = IN.texCoord1;
	uv1.xy = ((uv1.xy / uv1.w) * 0.5) + 0.5;
	
	// UV反転(レンダーターゲット指定時など)
	float a = 1 - inputShaderParam[2];
	float b = inputShaderParam[2];
	uv1.y = (uv1.y * a) + (1.0 - uv1.y) * b;	
	
	float4 _color = _tex2D(VariableSamplerState, TextureSampler, uv1.xy);
	_color *= IN.color;
	_color.rgb += IN.specular.rgb * IN.specular.a;
	clip(_color.a - inputAlphaThreshold);	//αテスト(Vitaで必要)
	return _color;
}

in	SpriteCT3D_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionTextureColor3D_CutinUV_FP(OUT);
}
#endif
	
//-----------------------------------------------------------------------------
//　ソフトパーティクル
// 位置、テクスチャ、色		(FVF_POSITION|FVF_NORMAL|FVF_TEXCOORD0|FVF_COLOR0)
//-----------------------------------------------------------------------------
#ifdef main_PositionNormalTextureColor3D_SoftParticleVP2
SpriteCT3D_VPOutput PositionNormalTextureColor3D_SoftParticleVP2(DefualtVPInput IN)
{
	SpriteCT3D_VPOutput OUT;
	
	// 座標
#if defined(INSTANCING_ENABLED)
	float4 localPosition = float4(IN.position.xyz,1.0);	
	ApplyInstanceTransformVertex(IN.instancingInput, localPosition.xyz);
	
	float4 color = IN.instancingInput.InstanceColor;
	float4 specular = float4(0.0, 0.0, 0.0, 0.0);
	ApplyInstanceColorSpecular(color, specular);
	
	OUT.color = IN.color * color;
	OUT.specular = specular;	
#else
	float4 localPosition = float4(IN.position.xyz,1.0);	
	
	OUT.color = IN.color * inputColor;
	OUT.specular = inputSpecular;	
#endif
	
	OUT.position = _mul(WorldViewProjection, localPosition);
	OUT.texCoord = getUV(IN.texCoord );
	OUT.texCoord1 = OUT.position;
	
	OUT.color.a *= getNearFadeFactor( OUT.position.z );	

#if defined(CS_PARTICLE_DITHER_ENABLE)
	float3 worldPosition = _mul(World, localPosition).xyz;
	float3 viewPosition = _mul(scene.View, float4(worldPosition.xyz, 1)).xyz;
	OUT.ditherParam.x = EvaluateDitherValue(viewPosition, GameDitherParams.x, GameDitherParams.y);
#endif	
	
	return OUT;
}

in	DefualtVPInput IN;
out	SpriteCT3D_VPOutput OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	DefualtVPInput IN_ = IN;
#ifdef INSTANCING_ENABLED
	IN_.instancingInput	= instancingInput;
#endif

	OUT = PositionNormalTextureColor3D_SoftParticleVP2(IN_);

	gl_Position		= OUT.position;
}
#endif

//-----------------------------------------------------------------------------
#ifdef main_PositionNormalTextureColor3D_SoftParticleFP2
float4 PositionNormalTextureColor3D_SoftParticleFP2(SpriteCT3D_VPOutput IN, float4 ScreenPosition)
{
#if defined(CS_PARTICLE_DITHER_ENABLE)
	// ディザリングによる距離クリップ
	clip(IN.ditherParam.x - GetDitherThreshold(ScreenPosition.xy));
#endif	
	
	float4 _color = _tex2D(VariableSamplerState, TextureSampler, IN.texCoord);
	_color *= IN.color;
	_color.rgb += IN.specular.rgb * IN.specular.a;

	clip(_color.a - inputAlphaThreshold);	//αテスト(Vitaで必要)

	float2 screenPos = (IN.texCoord1.xy / IN.texCoord1.w);
	float depthBuf = GetScreenSpaceDepth(DepthBuffer, screenPos * 0.5 + 0.5 );						// (-1.0～1.0) -> (0.0～1.0)
	
	// 描画する物の奥行き値
#if defined(PHYRE_D3DFX)
	float depthVal = (IN.texCoord1.z / IN.texCoord1.w);									// 0 - 1
#else
	float depthVal = (IN.texCoord1.z / IN.texCoord1.w) * 0.5 + 0.5;						// 0 - 1
#endif
	
	// ViewSpaceZ(m) に変換
	depthBuf = ConvertDepth(depthBuf);
	depthVal = ConvertDepth(depthVal);

	float fadeWidth = inputSoftCheckDepthParam.x;
	float depthDelta = (depthBuf - depthVal);
	float alphaA = depthDelta / fadeWidth;																							// 深度値が近い場合消す
	float alphaB = (depthBuf > depthVal) ? (1 - ((depthBuf - depthVal) / fadeWidth)) : (1 - ((depthVal - depthBuf) / fadeWidth));	// 深度値からプラス方向マイナス方向に消す
	
	float alpha = alphaA * (1-inputSoftCheckDepthParam.y) + alphaB * inputSoftCheckDepthParam.y;									// alphaA か alphaB 片方のみ有効にする

	alpha = saturate(alpha);
	_color.a *= alpha;
	
//	_color.rgba = float4(depthBuf,depthBuf,depthBuf,1);	//深度値テストコード
	
	return _color;
}

in	SpriteCT3D_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionNormalTextureColor3D_SoftParticleFP2(OUT, gl_FragCoord);
}
#endif
	
//-----------------------------------------------------------------------------
// デカール
//-----------------------------------------------------------------------------
#ifdef main_PositionNormalTextureColor3D_DeferredDecalVP
SpriteCT3D_VPOutput PositionNormalTextureColor3D_DeferredDecalVP(DefualtVPInput IN)
{
	SpriteCT3D_VPOutput OUT;

	float4 localPosition = float4(IN.position.xyz,1.0);	
	OUT.position = _mul(WorldViewProjection, localPosition);
	OUT.texCoord1 = OUT.position;
	OUT.texCoord = IN.texCoord;
	OUT.color = IN.color * inputColor;
	OUT.specular = inputSpecular;
	
#if defined(CS_PARTICLE_DITHER_ENABLE)
	OUT.ditherParam = 0;
#endif
	
	return OUT;
}

in	DefualtVPInput IN;
out	SpriteCT3D_VPOutput OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	DefualtVPInput IN_ = IN;
#ifdef INSTANCING_ENABLED
	IN_.instancingInput	= instancingInput;
#endif

	OUT = PositionNormalTextureColor3D_DeferredDecalVP(IN_);

	gl_Position		= OUT.position;
}
#endif

//-----------------------------------------------------------------------------
#ifdef main_PositionNormalTextureColor3D_DeferredDecalFP
float4 PositionNormalTextureColor3D_DeferredDecalFP(SpriteCT3D_VPOutput IN)
{
	float4 _color = IN.color;
	clip(_color.a - inputAlphaThreshold);	//αテスト(Vitaで必要)

	float2 screenPos = (IN.texCoord1.xy / IN.texCoord1.w);
	float depthBuf = GetScreenSpaceDepth(DepthBuffer, screenPos * 0.5 + 0.5);		// (-1.0～1.0) -> (0.0～1.0)
	float viewSpaceDepth = ConvertDepth(depthBuf);
	
	// screenPosition -> localPosition
	float4 viewPos = float4(screenPos * inputInvProjXY.xy * viewSpaceDepth, -viewSpaceDepth, 1);
	float3 localPos = _mul(WorldViewInverse, viewPos).xyz;
	
	// ローカル座標では xyz(-0.5～0.5) のボックスとして扱う
	clip(0.5 - abs(localPos.x));
	clip(0.5 - abs(localPos.y));
	clip(0.5 - abs(localPos.z));

	// UV化
	float2 uv = localPos.xz + 0.5;	// (-0.5～0.5) -> (0.0 -> 1.0)	xz平面で計算
	uv.x = inputUVShift.x * uv.x + inputUVShift.z,
	uv.y = inputUVShift.y * uv.y + inputUVShift.w;
	
	_color *= _tex2D(VariableSamplerState, TextureSampler, uv);
	_color.rgb += IN.specular.rgb * IN.specular.a;	
	
	// 淵を消す
	float radius = length(localPos.xyz);
	//clip(0.5-radius);	// 球でくりぬく場合

	_color.a *= getRimAlphaFactor( 1.0 - (radius * 2) );
	
	return _color;
}

in	SpriteCT3D_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionNormalTextureColor3D_DeferredDecalFP(OUT);
}
#endif
	
//-----------------------------------------------------------------------------
#ifdef main_PositionNormalTextureColor3D_DeferredFakeLightFP
float4 PositionNormalTextureColor3D_DeferredFakeLightFP(SpriteCT3D_VPOutput IN)
{
	float4 _color = IN.color;
	clip(_color.a - inputAlphaThreshold);	//αテスト(Vitaで必要)

	float2 screenPos = (IN.texCoord1.xy / IN.texCoord1.w);
	float depthBuf = GetScreenSpaceDepth(DepthBuffer, screenPos * 0.5 + 0.5 );						// (-1.0～1.0) -> (0.0～1.0)
	float viewSpaceDepth = ConvertDepth(depthBuf);
	
	// screenPosition -> localPosition
	float4 viewPos = float4(screenPos * inputInvProjXY.xy * viewSpaceDepth, -viewSpaceDepth, 1);
	float3 localPos = _mul(WorldViewInverse, viewPos).xyz;
	
	// ローカル座標では 半径0.5の球として扱う
	float radius = length(localPos.xyz);
	clip(0.5 - radius);
	
	// UV化
	float2 textureCoordinate = float2(inputUVShift.x * (radius * 2) + inputUVShift.z, inputUVShift.y + inputUVShift.w);	// (0～0.5) -> (0～1.0)
	_color *= _tex2D(VariableSamplerState, TextureSampler, textureCoordinate);
	_color.rgb += IN.specular.rgb * IN.specular.a;
	
	return _color;
}

in	SpriteCT3D_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionNormalTextureColor3D_DeferredFakeLightFP(OUT);
}
#endif
	
//-----------------------------------------------------------------------------
// Depthテクスチャ(DEPTH24) を Depthテクスチャ(DEPTH24)にレンダリング（コピー)する
//-----------------------------------------------------------------------------
struct CopyDepthVPOutput
{
	float4 position;
	float2 texCoord0;
	float2 texCoord1;
	float2 texCoord2;
	float2 texCoord3;
};

#ifdef main_CopyDepthToDepthVP
CopyDepthVPOutput CopyDepthToDepthVP(DefualtVPInput IN)
{
	CopyDepthVPOutput OUT;
	float4 localPosition = float4(IN.position.xyz,1.0);	
	OUT.position = localPosition;
	OUT.texCoord0 = IN.texCoord;
	
	float2 offset1	= float2( 1/inputDepthBufferSize.x,                      0.0 );
	float2 offset2	= float2( 1/inputDepthBufferSize.x, 1/inputDepthBufferSize.y );
	float2 offset3	= float2(                      0.0, 1/inputDepthBufferSize.y );

	OUT.texCoord1 = OUT.texCoord0 + offset1;
	OUT.texCoord2 = OUT.texCoord0 + offset2;
	OUT.texCoord3 = OUT.texCoord0 + offset3;

	OUT.texCoord0 *= float2(inputDownscaleFactor, inputDownscaleFactor);
	OUT.texCoord1 *= float2(inputDownscaleFactor, inputDownscaleFactor);
	OUT.texCoord2 *= float2(inputDownscaleFactor, inputDownscaleFactor);
	OUT.texCoord3 *= float2(inputDownscaleFactor, inputDownscaleFactor);

	return OUT;
}

in	DefualtVPInput IN;
out	CopyDepthVPOutput OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	DefualtVPInput IN_ = IN;
#ifdef INSTANCING_ENABLED
	IN_.instancingInput	= instancingInput;
#endif

	OUT = CopyDepthToDepthVP(IN_);

	gl_Position		= OUT.position;
}
#endif

#ifdef main_CopyDepthToDepthFP
half4 CopyDepthToDepthFP(CopyDepthVPOutput IN, out float outDepth)
{
	// 線形変換 すると far-nearが小さい(2000など)とうまくいかなくなる
	// currentDepth = (1.0/scene.cameraNearFarParameters.y) / ((scene.cameraNearFarParameters.y/(scene.cameraNearFarParameters.y - scene.cameraNearFarParameters.x)) - currentDepth);
	// currentDepth = 0.9123421234;
	// currentDepth = 0.123456;
	
	// 深度バッファへの書き込み
//	float currentDepth = ReadDepth( TextureSampler, IN.texCoord.xy );
//	outDepth = currentDepth;
	
	// 近隣ピクセルのZ値から最も”遠い”値を取得（キャラとエフェクトに隙間がなるべく隙間が出来ないように）
	float2 depth0,depth1;
	depth0.x = ReadDepth( DepthBuffer, IN.texCoord0.xy );
	depth0.y = ReadDepth( DepthBuffer, IN.texCoord1.xy );
	depth1.x = ReadDepth( DepthBuffer, IN.texCoord2.xy );
	depth1.y = ReadDepth( DepthBuffer, IN.texCoord3.xy );
	float2 result = max(depth0,depth1); 
	float currentDepth =  max(result.x, result.y);
	outDepth = currentDepth;
	
	//--------------------------------------------------
	// カラーバッファへ深度値を書き込み
	//深度値を RGB(8bitx3)に格納。
	// R成分抽出
	float R = floor( currentDepth * 255.0 ) / 255.0;	//round 指定された値を直近の整数値に丸めます
	// G成分抽出
	float Def = currentDepth - R;
	float G = floor( Def * 65535.0 ) / 255.0;			//floor パラメーター以上の最大の整数値
	// B成分抽出
	Def -= G/255.0;
	float B =  Def * 65535.0;// / 255.0;
	return half4(R, G, B, 0);	
}

in	CopyDepthVPOutput OUT;
out vec4 out_FragColor;
void main()
{
	float outDepth;

	out_FragColor = CopyDepthToDepthFP(OUT, outDepth);
}
#endif

//-----------------------------------------------------------------------------
float rand(float2 seed)
{
	return frac(sin(dot(seed, float2(12.9898,78.233))) * 43758.5453);
}
//-----------------------------------------------------------------------------
// ズームブラー
//-----------------------------------------------------------------------------
struct SpriteBlur_VPOutput
{
	float4 position;
	float4 color;
	float2 texCoord;
};

#ifdef main_PositionTextureColor2DZoomBlur_VP
SpriteBlur_VPOutput PositionTextureColor2DZoomBlur_VP(SpriteCT_VPInput IN)
{
	SpriteBlur_VPOutput OUT;
	half4 localPosition = float4(IN.position.xyz,1.0);	
	OUT.position = _mul(World, localPosition);
	OUT.position.x *= CameraAspectRatio;
	OUT.texCoord = IN.texCoord * inputUVShift.xy + inputUVShift.zw;
	OUT.color    = IN.color    * inputColor;
	return OUT;
}

in	SpriteCT_VPInput IN;
out	SpriteBlur_VPOutput OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	OUT = PositionTextureColor2DZoomBlur_VP(IN);

	gl_Position		= OUT.position;
}
#endif
#ifdef main_PositionTextureColor2DZoomBlur_FP
half4 PositionTextureColor2DZoomBlur_FP(SpriteBlur_VPOutput IN)
{
	const float sampleCount = 15.0;
	const float rateBySampleCount = 1.0 / sampleCount;

	float2 center = inputBlurParam.xy;
	float2 texuv = IN.texCoord.xy;
	float2 velocity = texuv - center;
	float3 destColor = float3(0.0,0.0,0.0);

	velocity.xy *= inputBlurParam.z;
	
	float random = rand(texuv);
	
	float count = 0;
    for(float i = 0.0; i < sampleCount; i++){
    	float percent = (i+random) * rateBySampleCount;
    	float2 sampledUv = texuv - (velocity * percent);
    	
#if defined(__psp2__)
    	half4 _col = tex2D<half4>(TextureSampler, sampledUv);
#else  	
    	half4 _col = _h4tex2D(LinearClampSamplerState, TextureSampler, sampledUv);
#endif // __psp2__
    	
    	destColor += float3(_col.rgb);  
    	count ++;
    }
    float4 _color = float4(destColor / count, 1.0);

	_color *= IN.color;
	_color.rgb += inputSpecular.rgb * inputSpecular.a;

	return _color;
}

in	SpriteBlur_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionTextureColor2DZoomBlur_FP(OUT);
}
#endif
	
//------------------------------------------------------------------------------
// 頂点シェーダー：3Dポリゴン用ズームブラー
//------------------------------------------------------------------------------
#ifdef main_PositionTextureColor3DZoomBlur_VP
SpriteCT3D_VPOutput PositionTextureColor3DZoomBlur_VP( DefualtVPInput IN )
{
	SpriteCT3D_VPOutput OUT;

	float4 localPosition = float4(IN.position.xyz,1.0);	
	OUT.position = _mul(WorldViewProjection, localPosition);
	OUT.texCoord = float2(0.0,0.0);
	OUT.texCoord1 = OUT.position;	
		
//#if (VP_FLAG & V_R)
#if defined(CS_PARTICLE_RIM_FADE)
	// リム透明	
	float3 worldPosition = _mul(World, localPosition).xyz;
	float3 cameraVec = normalize( getEyePosition() - worldPosition );
	float3 normalVec = normalize( _mul(World, float4(IN.normal.xyz,0)).xyz);	
	float alpha = abs( dot(cameraVec, normalVec) );

	alpha = float(getRimAlphaFactor(half(alpha)));
#else
	float	alpha = 1.0;
#endif
	
	OUT.specular = inputSpecular;
	OUT.color = IN.color * inputColor;
	OUT.color.a *= alpha;
	OUT.color.a *= getNearFadeFactor( OUT.position.z );
	
#if defined(CS_PARTICLE_DITHER_ENABLE)
	OUT.ditherParam = 0;
#endif

	return OUT;
};

in	DefualtVPInput IN;
out	SpriteCT3D_VPOutput OUT;
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	DefualtVPInput IN_ = IN;
#ifdef INSTANCING_ENABLED
	IN_.instancingInput	= instancingInput;
#endif

	OUT = PositionTextureColor3DZoomBlur_VP(IN_);

	gl_Position		= OUT.position;
}
#endif
	
#ifdef main_PositionTextureColor3DZoomBlur_FP
half4 PositionTextureColor3DZoomBlur_FP( SpriteCT3D_VPOutput IN )
{
	const float sampleCount = 15.0;
	const float rateBySampleCount = 1.0 / sampleCount;

	float2 center = inputBlurParam.xy * 0.5 + 0.5;						// 中心座標
	float2 texuv = ((IN.texCoord1.xy / IN.texCoord1.w) * 0.5) + 0.5;	// 頂点のスクリーン座標をUV化
	float2 velocity = texuv - center;
	float3 destColor = float3(0.0,0.0,0.0);
	
	velocity *= inputBlurParam.z;										// ブラー強さの適用
	
	float random = rand(texuv);
	
	float count = 0;
    for(float i = 0.0; i < sampleCount; i++){
    	float percent = (i + random) * rateBySampleCount;
    	float2 sampledUv = texuv - (velocity * percent);
    	
#if defined(__psp2__)
    	half4 _col = tex2D<half4>(TextureSampler, sampledUv);
#else  	
    	half4 _col = _h4tex2D(LinearClampSamplerState, TextureSampler, sampledUv);
#endif // __psp2__
    	
    	destColor += float3(_col.rgb);
    	count ++;
    }
    float4 _color = float4(destColor / count, 1.0);

	_color *= IN.color;
	_color.rgb += IN.specular.rgb * IN.specular.a;

	return _color;
}

in	SpriteCT3D_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionTextureColor3DZoomBlur_FP(OUT);
}
#endif
		
// マップ環境光の取得
half3 GetGlobalAmbientColor()
{
	return scene.GlobalAmbientColor.rgb;
}

	
//------------------------------------------------------------------------------
// テクニック：足跡（デカール＋法線マップ）環境、方向光の考慮あり
//------------------------------------------------------------------------------
struct Parallax3MT_VPOutput
{
	float4 position;
	float4 color;
	float4 specular;
	float2 texCoord0; // UV
	float4 positionPro; // 透視変換後座標
	float3 lightDir; 
};
	
#ifdef main_PositionNormalTextureColor3DFootPrint_VP
Parallax3MT_VPOutput PositionNormalTextureColor3DFootPrint_VP( DefualtVPInput IN )
{
	Parallax3MT_VPOutput OUT;
	
	float4 localPosition = float4(IN.position.xyz,1.0);	
	OUT.position = _mul(WorldViewProjection, localPosition);
	OUT.positionPro = OUT.position;
	
	// UV転置
	OUT.texCoord0 = IN.texCoord;	
	OUT.color = IN.color * inputColor;
	OUT.color.a *= getNearFadeFactor( OUT.position.z );

	//陰影
	float4 worldPos = _mul(World, localPosition);
	OUT.color.a *= getShadeFactor( worldPos.xyz );

	OUT.specular = inputSpecular;
	
	// デカールはボックス描画。各頂点も実際に描画される面とは違う。
	// ピクセルを描画する場所での法線にする必要がある。ピクセルの場所が決まるのはフラグメントシェーダー内。
	// ピクセル単位の法線がないと、以下の接空間変換がうまく行かない。
	// そのため、法線は上方向と仮定（XZ平面にデカールを投影と決めつける）
	// ６平面独立した法線を持った立方体なら行けるかもしれない。
	
	// 法線マップの水色まっ平らな部分（でこぼこしてないとこ）がz軸の向き
//	float3 localNormal =  float3(0.0, 1.0, 0.0);	
	
	// 接空間上への座標変換
//	float3 n = normalize(localNormal);
//	float3 t = normalize(cross(localNormal, float3(0.0, 0.0, 1.0)));
//	float3 b = cross(n, t);
	
	// 描画面をXZ平面と決めつけ（足跡用)。デカールの場合、頂点の法線情報は使えない。閃の軌跡Ⅳではライティングのためピクセル法線データがあるはず。
	float3 n = float3(0.0, 1.0, 0.0);	// 法線
	float3 t = float3(1.0, 0.0, 0.0);	// タンジェント(U座標系)
	float3 b = float3(0.0, 0.0, 1.0);	// タンジェント(V座標系)

	// デカール↓描画のときに光源の向きがおかしいです。
	
	// ワールド光源ベクトルをローカル座標系へ
	float3 lightDir = -_mul(WorldInverse, float4(inputDirectionalLightVec, 0.0)).xyz;
	
	// ロカール光源ベクトルを接空間座標系へ
	OUT.lightDir.x = dot(t, lightDir);
	OUT.lightDir.y = dot(b, lightDir);
	OUT.lightDir.z = dot(n, lightDir);
	OUT.lightDir = normalize(OUT.lightDir);	
	
	return OUT;
};

in	DefualtVPInput IN;
out	Parallax3MT_VPOutput OUT; 
out gl_PerVertex
{
    vec4 gl_Position;
};
void main()
{
	DefualtVPInput IN_ = IN;
#ifdef INSTANCING_ENABLED
	IN_.instancingInput	= instancingInput;
#endif

	OUT = PositionNormalTextureColor3DFootPrint_VP(IN_);

	gl_Position		= OUT.position;
}
#endif
		
#ifdef main_PositionTextureColor3DFootPrint_FP
//-----------------------------------------------------------------------------
// デカールUVを取得
//-----------------------------------------------------------------------------
float2 GetDecalUV( float4 position )
{
	float2 screenPos = (position.xy / position.w);
	float depthBuf = GetScreenSpaceDepth(DepthBuffer, screenPos * 0.5 + 0.5);		// (-1.0～1.0) -> (0.0～1.0)
	float viewSpaceDepth = ConvertDepth(depthBuf);
	
	// screenPosition -> localPosition
	float4 viewPos = float4(screenPos * inputInvProjXY.xy * viewSpaceDepth, -viewSpaceDepth, 1);
	float3 localPos = _mul(WorldViewInverse, viewPos).xyz;
	
	// ローカル座標では xyz(-0.5～0.5) のボックスとして扱う
	clip(0.5 - abs(localPos.x));
	clip(0.5 - abs(localPos.y));
	clip(0.5 - abs(localPos.z));

	// UV化
	float2 uv = localPos.xz + 0.5;	// (-0.5～0.5) -> (0.0 -> 1.0)	xz平面で計算
	uv.x = inputUVShift.x * uv.x + inputUVShift.z,
	uv.y = inputUVShift.y * uv.y + inputUVShift.w;
	
	return uv;
}
	
half4 PositionTextureColor3DFootPrint_FP(Parallax3MT_VPOutput IN)
{
	float4 _color = IN.color;
	clip(_color.a - inputAlphaThreshold);	//αテスト(Vitaで必要)
	
	// デカールUV取得
	float2 uv = GetDecalUV(IN.positionPro);

	// テクスチャ参照
	_color *= _tex2D(VariableSamplerState, TextureSampler, uv);
	
	clip(_color.a - inputAlphaThreshold);	//αテスト(Vitaで必要)	
	_color.rgb += inputSpecular.rgb * inputSpecular.a;
	
	// 法線マップから陰影
	float3 normal = _tex2D(VariableSamplerState1, Texture1Sampler, uv).xyz * 2.0 - 1.0;
	float shade = clamp( dot( normal, IN.lightDir ), 0.0, 1.0);	// 環境光分を加算して暗くならないようにしている

	// 環境光＋方向光
	float3 ambient = inputAmbientColor.xyz * inputAmbientColor.w;
	float3 directional = inputDirectina_Ligh_Color.xyz * inputDirectina_Ligh_Color.w * shade;
	_color.rgb *= (ambient + directional);
	
	return _color;
}

in	Parallax3MT_VPOutput OUT;
out vec4 out_FragColor;
void main()
{
	out_FragColor = PositionTextureColor3DFootPrint_FP(OUT);
}
#endif
